## 归并排序

归并排序运用递归的方式，先将子组合有序化，通过两个有序的子组进行对比把父组也有序化，特点如下：

-   整体就是一个简单递归，左边排好序，右边排好序，最后整体有序
-   让整体有序的过程用了<u>外排序</u>的方法
-   利用[master 公式](https://www.cnblogs.com/taobean/p/12364269.html)来求解时间复杂度

时间复杂度：O（N\*logN），额外空间复杂度 O（N）。空间复杂度是每次递归时 merge 函数中需要开辟 help 辅助数组

```typescript
// 归并排序
const arr = [1, 3, 2, 4, 5, 7, 6, 8];
const process: SortParams = (arr, L, R) => {
    if (L == R) return;
    const mid = L + ((R - L) >> 1);
    process(arr, L, mid);
    process(arr, mid + 1, R);
    merge(arr, L, mid, R);
};

const merge: Merge = (arr, L, M, R) => {
    console.log("🚀 ~ file: Sort.ts ~ line 9 ~ mid", L, M, R);
    const help: number[] = new Array(R - L + 1);
    let i = 0,
        p1 = L,
        p2 = M + 1;
    while (p1 <= M && p2 <= R) {
        help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= M) {
        help[i++] = arr[p1++];
    }
    while (p2 <= R) {
        help[i++] = arr[p2++];
    }
    // 对原数组对应位置进行修改
    for (let i = 0; i < help.length; i++) {
        arr[L + i] = help[i];
    }
};

process(arr, 0, arr.length - 1);
```

merge 函数调用顺序

```js
// 打印
🚀 ~ file: Sort.ts ~ line 9 ~ mid 0 0 1
🚀 ~ file: Sort.ts ~ line 9 ~ mid 2 2 3
🚀 ~ file: Sort.ts ~ line 9 ~ mid 0 1 3
🚀 ~ file: Sort.ts ~ line 9 ~ mid 4 4 5
🚀 ~ file: Sort.ts ~ line 9 ~ mid 6 6 7
🚀 ~ file: Sort.ts ~ line 9 ~ mid 4 5 7
🚀 ~ file: Sort.ts ~ line 9 ~ mid 0 3 7
```

流程图

![](D:\Project\image-host\img/归并-递归图.jpg)

------ 扩展练习

### 小和问题

![](D:\Project\image-host\img/image-20211226104942135.png)

```typescript
const smallSum: SmallSum = (arr, L, R) => {
    if (L == R) return 0;
    const mid = L + ((R - L) >> 1);
    return smallSum(arr, L, mid) + smallSum(arr, mid + 1, R) + smallSumMerge(arr, L, mid, R);
};
const smallSumMerge: SmallSumMerge = (arr, L, M, R) => {
    const help = new Array(R - L + 1);
    let i = 0,
        p1 = L,
        p2 = M + 1,
        res = 0;
    while (p1 <= M && p2 <= R) {
        res += arr[p1] < arr[p2] ? (R - p2 + 1) * arr[p1] : 0;

        help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= M) {
        help[i++] = arr[p1++];
    }
    while (p2 <= R) {
        help[i++] = arr[p2++];
    }
    for (let i = 0; i < help.length; i++) {
        arr[L + i] = help[i];
    }
    return res;
};
```

### 逆序对问题

![](D:\Project\image-host\img/image-20211226132949690.png)
