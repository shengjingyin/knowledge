# 树

## 术语

#### 树（Tree）

n 个节点构成的**有限集合**；当 n=0 时，称之为**空树**

#### 根（Root）

根节点

#### 子树（SubTree）

除了根节点，其余每个集合又是一棵树

#### 度（Degree）

节点的**子树个数**

![](https://gitee.com/sjy666666/image-host/raw/master/img/image-20211221235609908.png)

## 二叉树

### 五种形态

![](https://gitee.com/sjy666666/image-host/raw/master/img/image-20211221233309184.png)

### 特性

- 一个二叉树的**最大节点数**为：**2^(i - 1) ** , i > = 1;
- 深度为 k 的二叉树有最大节点总数为：**2^k - 1** , k >= 1;
- 对任何非空二叉树 T，若 n0 表述叶节点的个数，n1 是度为 2 的非叶子节点个数，则满足关系 **n0 = n1 + 1**

<img src="https://gitee.com/sjy666666/image-host/raw/master/img/image-20211221234423553.png" style="zoom: 33%;" />

## 完美二叉树

除了最下面一层的节点，每层节点都有两个子节点

<img src="https://gitee.com/sjy666666/image-host/raw/master/img/image-20211221234649407.png" style="zoom:50%;" />

## 完全二叉树

- 除了最后一层外，其余各层节点数达到最大；
- 且最后一层从左到右的叶子节点连续存在，只缺右侧若干叶子节点；
- 完美二叉树是特殊的完全二叉树

## \*二叉搜索树

### 特性

- 非空**左子树**的所有**键值小于**其**根节点的键值**
- 非空**右子树**的所有**键值大于**其**根节点的键值**
- 左、右子树本身也是二叉搜索树

由于有上面的特性，所有二叉搜索树**搜索效率非常高**

### 插入

```typescript
insert(key: number, value: any): Node {
    const newNode = new Node(key, value);
    if (!this.root) {
        this.root = newNode;
    } else {
        this._insert(this.root, newNode);
    }
    return newNode;
}
_insert(node: Node, newNode: Node): void {
    if (newNode.key < node.key) {
        if (node.left === null) {
            node.left = newNode;
        } else {
            this._insert(node.left, newNode);
        }
    } else {
        if (node.right === null) {
            node.right = newNode;
        } else {
            this._insert(node.right, newNode);
        }
    }
}
```

### 遍历

#### 先序遍历

- 访问根节点
- 先序遍历其左子树
- 先序遍历其右子树

![](https://gitee.com/sjy666666/image-host/raw/master/img/image-20211222204850280.png)

```typescript
type Handler = (obj: { key: number; value: any }) => any;

preOrderTraverse(handler: Handler): void {
    if (this.root !== null) {
        this._preOrderTraverse(this.root, handler);
    }
}
_preOrderTraverse(node: Node | null, handler: Handler): void {
    if (node !== null) {
        // 1、处理经过的节点
        handler({ key: node.key, value: node.value });
        // 2、处理经过的左子节点
        this._preOrderTraverse(node.left, handler);
        // 3、处理经过的右子节点
        this._preOrderTraverse(node.right, handler);
    }
}
```

#### 中序遍历

- 中序遍历其左子树
- 访问根节点
- 中序遍历其右子树

![](https://gitee.com/sjy666666/image-host/raw/master/img/image-20211222223904850.png)

```typescript
// 中序遍历
inOrderTraverse(handler: Handler): void {
    this._inOrderTraverse(this.root, handler);
}
_inOrderTraverse(node: Node | null, handler: Handler): void {
    if (node !== null) {
        // 1、处理经过的左子节点
        this._inOrderTraverse(node.left, handler);
        // 2、处理经过的节点
        handler({ key: node.key, value: node.value });
        // 3、处理经过的右子节点
        this._inOrderTraverse(node.right, handler);
    }
}
```

#### 后续遍历

- 后序遍历其左子树
- 后续遍历其右子树
- 访问根节点

![](https://gitee.com/sjy666666/image-host/raw/master/img/image-20211222230003790.png)

```typescript
// 后序遍历
postOrderTraverse(handler: Handler): void {
    this._postOrderTraverse(this.root, handler);
}
_postOrderTraverse(node: Node | null, handler: Handler): void {
    if (node !== null) {
        // 1、处理经过的左子节点
        this._postOrderTraverse(node.left, handler);
        // 2、处理经过的右子节点
        this._postOrderTraverse(node.right, handler);
        // 3、处理经过的节点
        handler({ key: node.key, value: node.value });
    }
}
```
