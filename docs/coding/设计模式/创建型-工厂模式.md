# 工厂模式

> 定义：将创建对象的过程单独封装

注意点：

- 将不变的进行封装，
- 变的交给一个函数（自定义预处理函数）去处理

假设需要录入员工信息，包含 name、age、career、work 这四个属性，假设

## 抽象工厂

优点：

- 完美体现开放封闭原则，新增工厂，新增产品只需要重新添加具体产品、具体工厂即可，对原有产品、工厂不影响

```js
// 抽象工厂不干活，不允许直接调用，需要子类实现该方法
// 抽象工厂
class MobilePhoneFactory {
  // 提供操作系统接口
  createOS() {
    throw new Error('抽象工厂函数，不允许直接调用，你需要将我重写');
  }
  // 提供硬件接口
  createHardWare() {
    throw new Error('抽象工厂函数，不允许直接调用，你需要将我重写');
  }
}
/* 明确某一条手机生产流水线具体要生产什么样的手机了之后，就可以化抽象为具体，
比如我现在想要一个专门生产 Android 系统 + 高通硬件的手机的生产线
我给这类手机型号起名叫 FakeStar */

// 具体工厂
class FakerStarFactory extends MobilePhoneFactory {
  createOS() {
    // 具体产品类 (往往具体产品类不是单一产品，可能有很多相似产品，比如windows和apple)
    // 具体产品类往往不会孤立存在，不同的具体产品类往往有着共同的功能，比如安卓系统类和苹果系统类，
    // 它们都是操作系统，都有着可以操控手机硬件系统这样一个最基本的功能
    /* 因此我们可以用一个抽象产品（AbstractProduct）类来声明这一类产品应该具有的基本功能 */
    return new AndroidOS();
  }
  createHardWare() {
    // 具体产品类
    return new QualcommHardWare();
  }
}

// 抽象产品（AbstractProduct）类
class OS {
  controlHardWare() {
    throw new Error('抽象工厂函数，不允许直接调用，你需要将我重写');
  }
}

// 定义具体产品类 - os
class AndroidOS extends OS {
  controlHardWare() {
    console.log('我会用android的方法控制hard');
  }
}
class AppleOS extends OS {
  controlHardWare() {
    console.log('我会用Apple的方法控制hard');
  }
}
// 抽象产品（AbstractProduct）类
class HardWare {
  operateByOrder() {
    throw new Error('抽象工厂函数，不允许直接调用，你需要将我重写');
  }
}

// 定义具体产品类 - 硬件
class QualcommHardWare extends HardWare {
  operateByOrder() {
    console.log('我会用高通的方式去运转');
  }
}
class MiWare extends HardWare {
  operateByOrder() {
    console.log('我会用小米的方式去运转');
  }
}
```

- 运行代码

  ```js
  const myPhone = new FakerStarFactory();

  const myOS = myPhone.createOS();
  const myHard = myPhone.createHardWare();

  myOS.controlHardWare();
  myHard.operateByOrder();
  ```

- 效果

![image-20220114210356813](https://gitee.com/sjy666666/image-host/raw/master/img/image-20220114210356813.png)

### 四个关键角色

- **抽象工厂（抽象类，它不能被用于生成具体实例）：** 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个（大家可以想象我们的手机厂后来被一个更大的厂收购了，这个厂里除了手机抽象类，还有平板、游戏机抽象类等等），每一个抽象工厂对应的这一类的产品，被称为“产品族”。
- **具体工厂（用于生成产品族里的一个具体的产品）：** 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。
- **抽象产品（抽象类，它不能被用于生成具体实例）：** 上面我们看到，具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。
- **具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）：** 比如我们上文中具体的一种操作系统、或具体的一种硬件等。
