# 防抖、节流

- 防抖（debounce）：当事件持续触发时，仅当**某一次的触发时间**与**前一次的触发时间**之差超过预设时间才会触发

  - 应用场景：只想知道最后一次触发时的状态，比如低代码平台中拖拽组件持续触发`dragover`事件，导致状态数据持续变化，要做到自动保存状态数据，可以使用防抖减少向服务器请求的次数

- 节流（throttle）：当事件持续触发时，会以预设时间的频率去**持续触发**
  - 应用场景：获取过程中的状态，比如飞书文档可以看到当前文档有谁正在查看，那么可以使用节流去轮询

## 防抖

这个概念通常与节流被一起讨论，因为他们的作用很相似，存在细微差别，共同之处都是用于解决函数（事件）被频繁调用的问题，需要减少函数（事件）的触发次数，因而得名防抖。

与它的名字类似，我先举个生活中形象的例子来说明防抖，想必电梯很熟悉吧，下面来一张大伙排队进入电梯的动漫图

![8644ebf81a4c510f660c27b12f0f6a2bd52aa](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3122d3c148434c109c3f97f313653378~tplv-k3u1fbpfcp-zoom-1.image)

看上图，大伙一个拍一个接着进入电梯，电梯会等到最后一个人进去之后，再过上设定好的秒数之后关闭电梯门，执行上或者下的函数。

这就是一个很形象的防抖，如果一直再触发防抖函数，那么防抖函数会等待触发的动机消停了，再等上设定好的时间，最后才会去执行回调函数。

再来一个实际开发中的案例:

监听滚动条滚动事件（实际上其它事件也可以创造这种条件，例如：鼠标移动）, 然后返回打印出滚动条距离顶部的高度

```js
window.onscroll = listenScroll;

function listenScroll() {
  let scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
  console.log('滚动条距离顶部的高度: ', scrollTop);
}
```

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dcb6b2729644aa38964ac04ac104019~tplv-k3u1fbpfcp-zoom-1.image" style="zoom: 33%;" />

仅仅是从上面滚动到下面,就打印了一大批.

虽然满足需求, 但这也引发出一个问题, 我真的需要这么频繁的去监听滚动事件吗? 假如我监听的事件处理里面是一个非常消耗性能的操作, 那这样不是白白浪费了浏览器性能吗?

有办法解决吗?

有 , 就和我上面介绍的上电梯是一个性质的问题, 解决办法就是 : 我等所有人都上来了, 再去执行关闭电梯门.

同理这里就是: 我等待用户停止操作滚动条了, 我再去回调函数, 至于这个怎么判断用户是否停止操作滚动条这就因人而异了(200ms 未操作滚动条 或者 300ms 也行)

这里给了一个简单版本的防抖函数,主要运用了**闭包**保存定时器

```js {7}
/**
 *
 * @param {function} fn - 回调函数
 * @param {number} delay - 等待时间
 */
function debounce(fn, delay) {
    let timer = null;  // 由闭包保存的局部变量
    return function () {
        // 这里表示如果有timer,则说明之前有调用过,解除之前的定时器;重新设置定时器计时回调函数触发的时机⏲
        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(fn, delay);
    };
}
function listenScroll () {
    // do
}
使用时则需要把上面监听的函数的方式改一下
window.onscroll = listenScroll
- 改成:
window.onscroll = debounce(listenScroll, 200)

```

![image-20220103102829414](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f2e4ee35d9e4508a22068d70dcee0fc~tplv-k3u1fbpfcp-zoom-1.image)

同样的回调函数经过`debounce`防抖处理之后我们看到效果已经好很多了仅仅触发了三次(滚动过程中我拖动滚动条有停顿, 手残党 😂 ) 这就能达到很好的降低触发回调函数的频率了!

### 应用场景

- scroll 滚动事件、浏览器窗口缩放事件、鼠标移动事件等等
- 搜索框输入查询事件
- 按钮提交事件（拒绝重复提交发送请求）

---

### 高配防抖

上文[防抖简介](https://juejin.cn/post/6998732773730615327)中简单介绍了一下防抖的使用场景以及一个简单点实现的例子。有没有功能丰富的防抖？有的，一些 JS 库基本也会封装防抖节流、 本文将阅读[underscore](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flessfish%2Funderscore-analysis%2Fblob%2Fmaster%2Funderscore-1.8.3.js%2Fsrc%2Funderscore-1.8.3.js)库中的防抖函数，这个函数主要解决了三个问题

- 执行函数的 this 指向问题
- 执行函数的参数获取问题
- 立即执行

### this 指向问题

这里`listenMoveOn`中打印的 this 指向 window，原因在于`listenMoveOn`是通过`setTimeout`调用的，还记得这是谁的方法吗？`window.setTimeout`，就是它`window`！！！所以`listenMoveOn`中的 this 指向 window

由于`onmousemove`监听的回调是`debounce`函数体返回的那个函数，所以这个函数体内的 this 是指向这个 dom 元素的

```js
function listenMoveOn() {
    // this -> window
}
function debounce(fn, delay) {
    ...
    return function () {
        // this -> dom
    };
}
```

既然事情已经明了，那么改变`listenMoveOn`函数体中的 this 指向应该不是难事了吧？如下使用 apply

```js
function listenMoveOn() {
    // this -> dom
}
function debounce(fn, delay) {
    ...
    return function () {
        // this -> dom
        ...
        timer = setTimeout(() => {
            fn.apply(this)			// 在这里改变listenMoveOn的this指向
        }, delay);
    };
}
```

### 传参问题

这个问题其实可以和 this 指向一起 解决，但是还是想多说两句，因为我监听鼠标移动的事件是`debounce`函数体返回的那个函数，js 事件通常都会返回一个事件对象，我目前只能在`debounce`中获取，在事件回调中是获取不到的，解决办法如下

```js
function listenMoveOn(...args) {
    let [event] = args
    // args可以获取到事件监听返回的事件对象
    // this -> dom
}
function debounce(fn, delay) {
    ...
    return function (...args) {
        // this -> dom
        ...
        timer = setTimeout(() => {
            fn.apply(this, args)	// 在这里改变listenMoveOn的this指向的同时传入监听对象获取到的参数
        }, delay);
        // 或者
        timer = setTimeout(fn.bind(this, ...args), delay) // 更简洁
    };
}
```

### 立即执行

使用 context、param 分别保存上下文、参数；用 timer 定义定时器，当前时间配合 timestamp 做间隔时间判断，result 保存函数调用结果

主函数：

- 保存上下文、参数；
- 更新 timestamp 时间快照；
- 做初始化时立即调用操作 & 注册定时器

later：

- 由于是 setTimeout 调用的，所以这个函数的调用不会很频繁，其中的 **+new Date() 是有可能 滞后 timestamp** 的
- 调用非立即执行的步骤

```js {6,9,22}
function debounce(fn: Function, delay: number, immediate: boolean) {
  let context, params, timer, timestamp, result;
  // 执行后续时间判断，函数调用
  const later = () => {
    // 调用间隔时间, 因为timestamp是一直变化的，但是+new Date() 是调用setTimeout后才能获取到
    const last = +new Date() - timestamp;
    if (last < delay && last >= 0) {
      // 重置
      timer = setTimeout(later, delay);
    } else {
      // 到这里整个流程结束，如果不是立即调用的，则在这里执行
      timer = null;
      if (!immediate) {
        result = fn.apply(context, ...params);
        context = params = null;
      }
    }
  };
  return function (this: unknown, ...args) {
    context = this;
    params = args;
    timestamp = +new Date(); // 更新时间快照

    let callNow = immediate && !timer;
    if (!timer) timer = setTimeout(later, delay);
    if (callNow) {
      result = fn.apply(context, ...params);
      context = params = null;
    }
    return result;
  };
}
```

在一个调用周期内，立即执行和非立即执行的运行次数是一样的，并且**次数是 1**，delay 期间内不会再去执行

- 如果是立即执行，那么在 delay 时间内，在开始时执行，
- 如果是立即执行，那么在 delay 时间结束后，在末尾时执行。

| 类别       | 0ms   | 200ms |
| ---------- | ----- | ----- |
| 立即执行   | **1** |       |
| 非立即执行 |       | **1** |

---

## 节流

节流应用于：当重复调用函数的时候，至少每隔 **wait**毫秒调用一次该函数。对于想控制一些触发频率较高的事件有帮助。就像是未完全打开的水龙头一样，一点一点的往下流，每一个点都相当于调用了一次回调函数。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a8f467c7e8e4d949dfe024a9d747fb1~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:25%;" />

节流常见应用场景有：

- 获取过程中的状态，比如飞书文档可以看到当前文档有谁正在查看，那么可以**使用节流去轮询**

### 版本一：时间戳实现

通过时间戳实现节流，这种方式会在进入 throttle 函数中就会触发事件监听回调

```js
/**
 *
 * @param {function} fn - 回调函数
 * @param {number} wait - 触发间隔时间
 */
function throttle(fn, wait) {
  let timer, old, now, context, args;
  old = 0;

  return function () {
    context = this;
    args = arguments;
    now = +new Date();
    if (now - old > wait) {
      // 因为 now - 0 必定大于wait，所以这种实现方式 首次肯定会触发
      fn.apply(context, args);
      old = now;
    }
  };
}
```

### 版本二：`setTimeout`实现

使用`setTimeout`实现节流，要等到时间达标才会去触发，所以首次不会触发，后面出去之后由于有`setTimeout`的存在，还会补上一次

```js
/**
 *
 * @param {function} fn - 回调函数
 * @param {number} wait - 触发间隔时间
 */
function throttle(fn, wait) {
  let timer, context, args;

  return function () {
    context = this;
    args = arguments;
    if (!timer) {
      timer = setTimeout(() => {
        timer = null; // 确保下次进来时能够重新设置定时器
        fn.apply(context, args);
      }, wait);
    }
  };
}
```

---

### 高配节流

前文讲到两种实现版本的节流，这里的高配版本主要将把这两种版本进行优势互补，合并成一个节流函数

### 分析

使用`时间戳`可以让节流函数立即执行，使用`setTimeout`可以让节流函数延迟执行，通过变量控制即可以达到以上需求

通过高配版的节流 ，达到配置以下四种情况：

- 开始执行，末尾不执行
- 开始不执行，末尾执行
- 开始执行，末尾执行
- 开始不执行，末尾不执行

### 代码实现

```js
/**
 *
 * @param {function} fn - 回调函数
 * @param {number} wait - 等待时间
 * @param {obejct} options - 配置三种情况
 *   options = {leading: true, trailing: false}； leading 控制第一次是否执行； trailing 控制最后一次是否执行
 */
function throttle(fn, wait, options) {
  /**
   *
   * @param timer - 定时器
   * @param now - 当前时间
   * @param context - 保存上下文使用
   * @param args - 保存事件参数使用
   */
  let timer, now, context, args;
  old = 0;

  // 设置默认情况（第一次执行，最后一次不执行）
  if (!options) options = { leading: true, trailing: false };

  const later = () => {
    // 这里重置old 是为了避免leading、trailing同时为true与时间戳那边相互影响，这一步相当于清除了时间戳那边的操作
    old = now;

    clearTimeout(timer);
    timer = null;
    fn.apply(context, args);
  };

  return function () {
    // 同防抖一样，需要闭包保存相关变量
    now = +new Date();
    context = this;
    args = arguments;

    // 配置 leading 走时间戳管理节流
    if (options.leading && now - old > wait) {
      // 这里重置定时器 是为了避免leading、trailing同时为true时与定时器那边相互影响，这一步相当于清除了定时器那边的操作
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }

      old = now;
      fn.apply(context, args);
    }
    // 配置 trailing 走定时器管理节流
    if (options.trailing && !timer) {
      timer = setTimeout(later, wait);
    }
  };
}
```

### undercore 中的 throttle

最后还是欣赏一下 undercore 中的 throttle 源码

```js
_.throttle = function (func, wait, options) {
  var context, args, result;
  var timeout = null;
  var previous = 0;
  if (!options) options = {};

  var later = function () {
    // 定时器方式
    previous = options.leading === false ? 0 : _.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  return function () {
    var now = _.now();
    if (!previous && options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    // 时间戳方式
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
};
```

