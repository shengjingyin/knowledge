## 解答防抖

这个概念通常与节流被一起讨论，因为他们的作用很相似，存在细微差别，共同之处都是用于解决函数（事件）被频繁调用的问题，需要减少函数（事件）的触发次数，因而得名防抖。

与它的名字类似，我先举个生活中形象的例子来说明防抖，想必电梯很熟悉吧，下面来一张大伙排队进入电梯的动漫图

![8644ebf81a4c510f660c27b12f0f6a2bd52aa](D:\Project\image-host\img\8644ebf81a4c510f660c27b12f0f6a2bd52aa52a.jpeg)

看上图，大伙一个拍一个接着进入电梯，电梯会等到最后一个人进去之后，再过上设定好的秒数之后关闭电梯门，执行上或者下的函数。

这就是一个很形象的防抖，如果一直再触发防抖函数，那么防抖函数会等待触发的动机消停了，再等上设定好的时间，最后才会去执行回调函数。

再来一个实际开发中的案例:

监听滚动条滚动事件（实际上其它事件也可以创造这种条件，例如：鼠标移动）, 然后返回打印出滚动条距离顶部的高度

```js
window.onscroll = listenScroll;

function listenScroll() {
	let scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
	console.log("滚动条距离顶部的高度: ", scrollTop);
}
```

<img src="D:\Project\image-host\img/image-20210820224526410.png" style="zoom: 33%;" />

仅仅是从上面滚动到下面,就打印了一大批.

虽然满足需求, 但这也引发出一个问题, 我真的需要这么频繁的去监听滚动事件吗? 假如我监听的事件处理里面是一个非常消耗性能的操作, 那这样不是白白浪费了浏览器性能吗?

有办法解决吗?

​ 有 , 就和我上面介绍的上电梯是一个性质的问题, 解决办法就是 : 我等所有人都上来了, 再去执行关闭电梯门.

​ 同理这里就是: 我等待用户停止操作滚动条了, 我再去回调函数, 至于这个怎么判断用户是否停止操作滚动条这就因人而异了(200ms 未操作滚动条 或者 300ms 也行)

这里给了一个简单版本的防抖函数,主要运用了**闭包**保存定时器

```js
/**
 *
 * @param {function} fn - 回调函数
 * @param {number} delay - 等待时间
 */
function debounce(fn, delay) {
    let timer = null;
    return function () {
        // 这里表示如果有timer,则说明之前有调用过,解除之前的定时器;重新设置定时器计时回调函数触发的时机⏲
        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(fn, delay);
    };
}

使用时则需要把上面监听的函数的方式改一下
window.onscroll = listenScroll
- 改成:
window.onscroll = debounce(listenScroll, 200)

```

![image-20220103102829414](D:\Project\image-host\img/image-20220103102829414.png)

同样的回调函数经过`debounce`防抖处理之后我们看到效果已经好很多了仅仅触发了三次(滚动过程中我拖动滚动条有停顿, 手残党 😂 ) 这就能达到很好的降低触发回调函数的频率了!但同时这里也会有一些问题，后续我将补上这里究竟存在什么样的问题，以及补充解答一个高配版的防抖函数（[underscore](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flessfish%2Funderscore-analysis%2Fblob%2Fmaster%2Funderscore-1.8.3.js%2Fsrc%2Funderscore-1.8.3.js)）

### 应用场景

-   scroll 滚动事件
-   搜索框输入查询事件
-   表单验证
-   按钮提交事件
-   浏览器窗口缩放事件

---

## 高配防抖

上文[防抖简介](https://juejin.cn/post/6998732773730615327)中简单介绍了一下防抖的使用场景以及一个简单点实现的例子, 支持一般的需求，它存在一些使用方面的限制，譬如

有没有功能丰富的防抖?

有! 它来了 本文将解答一个高配版本的防抖[underscore](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flessfish%2Funderscore-analysis%2Fblob%2Fmaster%2Funderscore-1.8.3.js%2Fsrc%2Funderscore-1.8.3.js)库中的防抖函数，这个函数主要解决了三个问题

-   执行函数的 this 指向问题
-   执行函数的参数获取问题
-   立即执行

> 先介绍一下实例应用背景：有一个 div，在 div 上移动触发回调函数`listenMoveOn`，这里使用了简单版本的防抖，如下代码所示

```html
<style>
	div {
		background-color: #666;
		height: 300px;
	}
</style>

<div></div>

<script>
	let dom = document.getElementsByTagName("div")[0];
	dom.onmousemove = debounce(listenMoveOn, 200);

	function listenMoveOn() {
		// 监听的回调做一些事情
	}
	/**
	 *
	 * @param {function} fn - 回调函数
	 * @param {number} delay - 等待时间
	 */
	function debounce(fn, delay) {
		var timer = null;
		return function (...args) {
			clearTimeout(timer);
			timer = setTimeout(fn, delay);
		};
	}
</script>
```

### this 指向问题

这里`listenMoveOn`中打印的 this 指向 window，原因在于`listenMoveOn`是通过`setTimeout`调用的，还记得这是谁的方法吗？`window.setTimeout`，就是它`window`！！！所以`listenMoveOn`中的 this 指向 window

由于`onmousemove`监听的回调是`debounce`函数体返回的那个函数，所以这个函数体内的 this 是指向这个 dom 元素的

```js
function listenMoveOn() {
    // this -> window
}
function debounce(fn, delay) {
    ...
    return function () {
        // this -> dom
    };
}
```

既然事情已经明了，那么改变`listenMoveOn`函数体中的 this 指向应该不是难事了吧？如下使用 apply

```js
function listenMoveOn() {
    // this -> dom
}
function debounce(fn, delay) {
    ...
    return function () {
        // this -> dom
        ...
        timer = setTimeout(() => {
            fn.apply(this)			// 在这里改变listenMoveOn的this指向
        }, delay);
    };
}
```

### 传参问题

这个问题其实可以和 this 指向一起 解决，但是还是想多说两句，因为我监听鼠标移动的事件是`debounce`函数体返回的那个函数，就是下图我红色框框框住的位置，js 事件通常都会返回一个事件对象，我目前只能在`debounce`中获取，在事件回调中是获取不到的，解决办法如下

```js
function listenMoveOn(...args) {
    let [event] = args
    // args可以获取到事件监听返回的事件对象
    // this -> dom
}
function debounce(fn, delay) {
    ...
    return function (...args) {
        // this -> dom
        ...
        timer = setTimeout(() => {
            fn.apply(this, args)	// 在这里改变listenMoveOn的this指向的同时传入监听对象获取到的参数
        }, delay);
    };
}
```

### 立即执行

这个实现起来有点复杂，对于源码我也稍加改变，功能实现原理一样

```js
function listenMoveOn(...args) {
	// 监听的回调做一些事情
	// this -> dom
	// args -> [event]
}

/**
 *
 * @param {function} fn - 回调函数
 * @param {number} delay - 等待时间
 * @param {boolean} immediate - 是否立即执行
 */
function debounce(fn, delay, immediate = false) {
	/**
	 *
	 * @param timer - 定时器
	 * @param timestamp - 当前时间
	 * @param context - 保存上下文使用
	 * @param param - 保存事件参数使用
	 */
	let timer, timestamp, context, param;

	const later = function () {
		let last = +new Date() - timestamp; // 距离上一次操作的时间间隔ms
		if (last < delay && last >= 0) {
			timer = setTimeout(later, delay); // 重置定时器
		} else {
			// 进入 else 说明设置的delay时间已经到了
			timer = null; // 清除闭包中的保存的变量，并且如果有后续的话，可以让立即调用中的callNow更改为true，进行调用事件回调函数
			if (!immediate) {
				fn.apply(context, param); // 如果immediate = false需要调用一下事件处理函数；当immediate = true 时，因为立即调用过，所以在后面就不需要调用，在本段代码 倒数第五行 执行立即调用
				context = param = null; // 清除闭包中的保存的变量
			}
		}
	};

	return function (...args) {
		context = this; // 保存变量到闭包内，方便后面调用时拿到值
		param = args;
		timestamp = +new Date();

		let callNow = immediate && !timer; // 当 immediate 设置true，并且timer还没有被赋值时，说明刚进来，可进行立刻调用，下面一句话就会重新赋值timer
		if (!timer) timer = setTimeout(later, delay); // 当第一次进入或者timer被清除后（表示已经调用过一次）才能再继续设置timer
		if (callNow) {
			fn.apply(context, args); // 立即执行的调用一直都是在这里,后面如果还有继续操作，也是在这里调用
			context = param = null; // 清除闭包中的保存的变量
		}
	};
}
```

其实立即执行和非立即执行的运行次数是一样的，就看你想要有区别的一次是开始执行，还是放在末尾执行

就像下面这样（这里的数值可以当作时间）

| 类别       |       |     |     |       |
| ---------- | ----- | --- | --- | ----- |
| 立即执行   | **0** | 1   | 2   |       |
| 非立即执行 |       | 1   | 2   | **3** |
|            |       |     |     |       |

### underscore 中的 debounce 源码欣赏

```js
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
_.debounce = function (func, wait, immediate) {
	var timeout, args, context, timestamp, result;

	var later = function () {
		var last = _.now() - timestamp;

		if (last < wait && last >= 0) {
			timeout = setTimeout(later, wait - last);
		} else {
			timeout = null;
			if (!immediate) {
				result = func.apply(context, args);
				if (!timeout) context = args = null;
			}
		}
	};

	return function () {
		context = this;
		args = arguments;
		timestamp = _.now();
		var callNow = immediate && !timeout;
		if (!timeout) timeout = setTimeout(later, wait);
		if (callNow) {
			result = func.apply(context, args);
			context = args = null;
		}

		return result;
	};
};
```

[本文源码地址](https://gitee.com/sjy666666/juejin-case/blob/master/js%E5%9F%BA%E7%A1%80/%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81.html)

## 解答节流

> 前文完整介绍了节流的兄弟：防抖（[初始防抖](https://juejin.cn/post/6998732773730615327)、[从 underscore 库中学习 debounce](https://juejin.cn/post/6999118646140370957/#heading-0)，假设掘友暂时不了解这个，相信从这两篇中掘友定会有所收获），本文开始讲解节流

节流应用于：当重复调用函数的时候，至少每隔 **wait**毫秒调用一次该函数。对于想控制一些触发频率较高的事件有帮助。就像是未完全打开的水龙头一样，一点一点的往下流，每一个点都相当于调用了一次回调函数。

<img src="D:\Project\image-host\img/image-20210822164117591.png" style="zoom:25%;" />

节流常见应用场景有以下几种：

-   dom 元素拖拽
-   计算鼠标移动的距离
-   监听 scroll 滚动

> 先介绍一下实例应用背景：有一个 div，在 div 上移动触发回调函数`listenMoveOn`，这里使用了简单版本的节流，如下代码所示

### 第一时间触发，末尾不触发

通过时间戳实现节流，这种方式会在进入 throttle 函数中就会触发事件监听回调

```html
<style>
	div {
		background-color: #666;
		height: 300px;
	}
</style>

<div></div>

<script>
	let dom = document.getElementsByTagName("div")[0];
	dom.onmousemove = throttle(listenMoveOn, 200);

	function listenMoveOn() {
		// 监听的回调做一些事情
	}
	/**
	 *
	 * @param {function} fn - 回调函数
	 * @param {number} wait - 触发间隔时间
	 */
	function throttle(fn, wait) {
		let timer, old, now, context, args;
		old = 0;

		return function () {
			now = +new Date();
			context = this;
			args = arguments;
			if (now - old > wait) {
				// 因为 now - 0 必定大于wait，所以这种实现方式 首次肯定会触发
				fn.apply(context, args);
				old = now;
			}
		};
	}
</script>
```

### 不立即触发，末尾触发

使用`setTimeout`实现节流，要等到时间达标才会去触发，所以首次不会触发，后面出去之后由于有`setTimeout`的存在，还会补上一次

```html
<script>
	/**
	 *
	 * @param {function} fn - 回调函数
	 * @param {number} wait - 触发间隔时间
	 */
	function throttle(fn, wait) {
		let timer, context, args;

		return function () {
			context = this;
			args = arguments;
			if (!timer) {
				timer = setTimeout(() => {
					timer = null; // 确保下次进来时能够重新设置定时器
					fn.apply(context, args);
				}, wait);
			}
		};
	}
</script>
```

### 小结

本节主要讲了两个版本类型的节流方式实现，这两种方式都各有特色，下一节将参考 underscore 中的 throttle 进行解析高配版本的节流。

---

## 高配节流

前文讲到两种实现版本的节流，这里的高配版本主要将把这两种版本进行优势互补，合并成一个节流函数，通过传参控制具体是要第一时间执行、或者最后一次执行，又或者两者兼得这三种情况

### 分析

使用`时间戳`可以让节流函数立即执行，使用`setTimeout`可以让节流函数延迟执行，通过变量控制即可以达到以上需求

通过高配版的节流 ，达到配置以下三种情况：

-   第一次执行，末尾不执行
-   第一次不执行，末尾执行
-   第一次执行，末尾执行

> 首先还是介绍一下实例应用背景：有一个 div，在 div 上移动触发回调函数`listenMoveOn`，还是这么一个简单的例子，具体还是通过代码去实现看看，详细内容通过注释体现

### 代码实现

```html
<style>
	div {
		background-color: #666;
		height: 300px;
	}
</style>

<div></div>

<script>
	let dom = document.getElementsByTagName("div")[0];
	dom.onmousemove = throttle(listenMoveOn, 200);

	function listenMoveOn() {
		// 监听的回调做一些事情
	}

	/**
	 *
	 * @param {function} fn - 回调函数
	 * @param {number} wait - 等待时间
	 * @param {obejct} options - 配置三种情况
	 *   options = {leading: true, trailing: false}； leading 控制第一次是否执行； trailing 控制最后一次是否执行
	 */
	function throttle(fn, wait, options) {
		/**
		 *
		 * @param timer - 定时器
		 * @param now - 当前时间
		 * @param context - 保存上下文使用
		 * @param args - 保存事件参数使用
		 */
		let timer, now, context, args;
		old = 0;

		// 设置默认情况（第一次执行，最后一次不执行）
		if (!options) options = { leading: true, trailing: false };

		const later = () => {
			// 这里重置old 是为了避免leading、trailing同时为true与时间戳那边相互影响，这一步相当于清除了时间戳那边的操作
			old = now;

			clearTimeout(timer);
			timer = null;
			fn.apply(context, args);
		};

		return function () {
			// 同防抖一样，需要闭包保存相关变量
			now = +new Date();
			context = this;
			args = arguments;

			// 配置 leading 走时间戳管理节流
			if (options.leading && now - old > wait) {
				// 这里重置定时器 是为了避免leading、trailing同时为true时与定时器那边相互影响，这一步相当于清除了定时器那边的操作
				if (timer) {
					clearTimeout(timer);
					timer = null;
				}

				old = now;
				fn.apply(context, args);
			}
			// 配置 trailing 走定时器管理节流
			if (options.trailing && !timer) {
				timer = setTimeout(later, wait);
			}
		};
	}
</script>
```

### undercore 中的 throttle

最后还是欣赏一下 undercore 中的 throttle 源码

```js
_.throttle = function (func, wait, options) {
	var context, args, result;
	var timeout = null;
	var previous = 0;
	if (!options) options = {};

	var later = function () {
		// 定时器方式
		previous = options.leading === false ? 0 : _.now();
		timeout = null;
		result = func.apply(context, args);
		if (!timeout) context = args = null;
	};
	return function () {
		var now = _.now();
		if (!previous && options.leading === false) previous = now;
		var remaining = wait - (now - previous);
		context = this;
		args = arguments;
		// 时间戳方式
		if (remaining <= 0 || remaining > wait) {
			if (timeout) {
				clearTimeout(timeout);
				timeout = null;
			}
			previous = now;
			result = func.apply(context, args);
			if (!timeout) context = args = null;
		} else if (!timeout && options.trailing !== false) {
			timeout = setTimeout(later, remaining);
		}
		return result;
	};
};
```

## 总结

防抖节流已经全部讲完，通过深入学习也算有所收获啦，以前只知道调用没详细了解原理，这回彻底搞懂了 😄 爱了爱了

> 防抖节流文章目录：
>
> -   [初始防抖](https://juejin.cn/post/6998732773730615327)
> -   [从 underscore 库中学习高阶防抖](https://juejin.cn/post/6999118646140370957/#heading-0)
> -   [初始节流](https://juejin.cn/post/6999567361216872478)
> -   本文就算是防抖节流的结尾了
