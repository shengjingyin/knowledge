闭包的定义：**闭包有权访问另一个函数作用域中的变量的函数**，从这里可以解读到两点：

- 闭包是一个函数
- 闭包能访问其它函数中的变量

> 简单理解就是：闭包是一个函数，并且能访问其它函数中的变量，实际上是阻止了变量因为生命周期而销毁

闭包有三个特性

- 1、闭包可以访问当前函数以外的变量

```js {2,4}
function getOuter() {
  const date = '815';
  function getDate(str) {
    console.log(str + date); // 访问另一个函数作用域中的变量 date
  }
  return getDate('今天是：'); //"今天是：815"
}
getOuter();
```

- 2、即使外部函数已经返回，闭包仍能访问外部函数定义的变量

```js {4}
function getOuter() {
  var date = '815';
  function getDate(str) {
    console.log(str + date); //访问外部的date
  }
  return getDate; //外部函数返回
}
var today = getOuter();
today('今天是：'); //"今天是：815"
today('明天不是：'); //"明天不是：815"
```

- 3、闭包可以更新外部变量的值

```js {2,4}
function updateCount() {
  var count = 0;
  function getCount(val) {
    count = val;
    console.log(count);
  }
  return getCount; //外部函数返回
}
var count = updateCount();
count(815); //815
count(816); //816
```

## 作用域链

作用域链是一套规则，这套规则用于管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找

理解闭包需要理解两个核心概念：**变量的作用域**、**变量的生存周期**。

### 变量的作用域

> 就是变量的有效范围

### 变量的生存周期

- 全局变量，永久（除非程序退出或者主动销毁这个变量）

- 局部变量，在函数内声明的变量，在函数退出时，这些局部变量也就失去了它们存在的价值，它们都会随着函数的调用结束而被销毁

#### 函数退出时，销毁变量

```js
let func = function () {
  let a = 1;
};
func();
```

#### 函数退出时，未销毁变量

```
let func = function() {
 	let a = 1;
 	return function() {
 		a++;
 		alert(a);
 	}
}

const f  = func();

f();	// 2
f();	// 3
f();	// 4
```

和上述声明周期不同，函数退出后，a 变量没有销毁，这里产生的便是一个闭包结构

## 应用场景

应用于想要保存某种变量状态，或者保存一些私有数据，不想让它 dead，这种情况选择闭包是个不错的选择，接着看看应用闭包的几个实例

### 1、防抖、节流

### 2、缓存计算结果

核心：使用闭包缓存结果

```js
function cacheCalculate(fn) {
    const cache = {}
    return function(cacheKey, ...args) {
        if (!cache[cacheKey]) {
            const value = fn.apply(fn, args)
            cache[cacheKey] = value
        }
        return cache[cacheKey]
    }
},
```

使用：

```js
// 1、提前声明好缓存的函数
function mounted() {
    this.cache = this.cacheCalculate(this.calculateCityLine)
},
// 2、运行中使用
const {lineData, planeData, gridData} =  this.cache('城市线面计算', data)
```

效果：

![image-20220307111103018](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba9cd4c093f94167bc31439866817cb5~tplv-k3u1fbpfcp-zoom-1.image)

### 3、分批传参，拆解参数，函数柯里化

### 4、数据上报

```js
const report = function (src) {
  const img = new Image();
  img.src = src;
};

report('http://juliya.icu/report'); // 发送请求
```

在**低版本浏览器**中，上述方法会丢失 30%左右的数据（并不是每一次都成功发送请求），因为 img 是局部变量，当 report 调用结束后，img 被销毁，此时或许还没有发送请求，所以请求会丢失，通过闭包就可以解决这个问题

```js
const report = (function () {
  const imgs = [];
  return function (src) {
    const img = new Image();
    imgs.push(img); // 临时存储img对象给闭包属性imgs，避免img被销毁
    img.src = src;
  };
})();

report('http://juliya.icu/report'); // 发送请求
```

### 5、函数柯里化

![image-20221114075021517](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fb9f98d4cc34970bb84a011cdd8b0e8~tplv-k3u1fbpfcp-zoom-1.image)