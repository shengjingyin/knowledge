## 什么是原型链？

JS 中的对象有一个特殊的`[[Prototype]]`内置属性，这是一个对于其它对象的引用。当试图访问对象的属性时，会触发`[[get]]`操作，默认先检查对象自身有没有这个属性，如果没有就需要使用`[[Prototype]]`链，通过这个原型链一层一层往上找，有则返回，没有则返回 undefined

## 原型链的应用场景？

更多的应用场景在于提取公共属性、方法等，例如在 es5 中声明一个类，提取公用方法 `sing`

```js {3}
function Person() {}

Person.Prototype.sing = function () {
  console.log('ddd');
};
```

## 原型链中的一些规律

先来张祖传原型链图，是不是很熟悉？

![原型链.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14ab4e648b6745ee87520881e8798494~tplv-k3u1fbpfcp-watermark.awebp)

### one

介绍原型链之前，先通过一个例子介绍三个概念：**实例对象**、**构造函数**、**原型对象**

```js
function Foo(name) {
  this.name = name;
}

const f1 = new Foo('zs');
```

- 实例对象：通过构造函数 new 出来的，本例中的`f1`，有`__proto__`属性

- 构造函数：`Foo`，（如果不使用 new 操作符的话，其实也是普通函数），有`prototype`属性

- 原型对象：new 操作符的执行过程中，会生成一个对象（能够生成桥梁连接**对象**与**构造函数**），这里有一个关联的公式，**很重要**：

  - **实例对象 的 `__proto__` 属性 与 构造函数 的 `prototype` 属性 指向同一个原型对象**

  - ```jsx
    f1.__proto__ === Foo.prototype; // true
    ```

**上面祖传的图片都将围绕这一个定律进行展开、扩展！！！所以这一定律很重要，是熟悉原型链的基本必要知识！！！**

### two

**函数也是对象**，所有的函数都是对象，`function Object()`、`function Foo()`、`function Function()`等等一系列的函数既是对象也是函数！这就意味着函数也有实例对象的`__proto__`属性，可以进而得到这些函数对象是由构造函数`Function`构造而来

所以出现下面这种盛况，所有的函数的原型对象都是`Function.prototype`，包括 Object 和 Function，**记住函数（万物）也是对象**

```js
Foo.__proto__ === Function.prototype; // true
Object.__proto__ === Function.prototype; // true
Function.__proto__ === Function.prototype; // true
```

### three

所有的原型对象（`Foo.prototype`、`Function.prototype`）也都是**对象**（不要看着图上画的是`Foo.prototype`、`Function.prototype`就以为它不是对象了），换个问题：那么对象的原型对象指向哪里呢？**因为对象是由 Object 构造函数创建的，所以对象的原型对象是`Object.prototype`。**

`Foo.prototype`、`Function.prototype`是指向构造函数的原型对象（也就是对象），由上面得对象的`__proto__`属性是指向`Object.prototype`的

那么就有了以下的规则出现

```jsx
Foo.prototype.__proto__ === Object.prototype; // true
Function.prototype.__proto__ === Object.prototype; // true
```

### four

食物链有顶端，那么原型链也有顶端，那就是`Object.prototype`，`Object.prototype`的原型对象是`null`，再往上就没有，如果找到这里还没有找到需要的属性，那么返回`undefined`

所以有下面这一条规则

```jsx
Object.prototype.__proto__ === null; // true
```

---

## 解读原型链图

前文讲了四个理解原型链图重要的概念，也是理解我今天手撕原型链图的理论基石，如果读者还不了解，欢迎点击链接[原型链四个重要概念](https://juejin.cn/post/7000700538232766472/)回顾

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6e8c36f498844618cbc2962a2ffce1a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" />

这回我们逐个分解原型链关系

### 第一部分

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f85986dbd5294fcf989904404bd757bb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:50%;" />

能看出运用哪条概念吗？最重要的一条，第一条 构造函数的`prototype`属性与实例对象的`__proto__`属性指向相同一个原型对象

> 注：这里我用了 `蓝色` 的画笔代表实例对象去原型对象的路线；了 `绿色` 的画笔代表构造函数去原型对象的路线，后面也都是用这样的表示方法，不再注解了。

```jsx
f1.__proto__ === Foo.prototype; // true
```

同理还有：

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3ebe8efc61147b4b4e64bfe2035f972~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:50%;" />

```jsx
o1.__proto__ === Object.prototype; // true
```

### 第二部分

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6d606509cd547b3a431efd1d2be686a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom: 50%;" />

从上面的启发能看出来吗？这是运用了第二条！**函数也是对象**，所有的函数都是对象，`function Object()`、`function Foo()`、`function Function()`等等一系列的函数既是对象也是函数！这就意味着**函数也有实例对象的`__proto__`属性**，可以进而得到**这些函数的原型对象是由构造函数`Function`构造而来**。

```jsx
Foo.__proto__ === Function.prototype; // true
Object.__proto__ === Function.prototype; // true
Function.__proto__ === Function.prototype; // true
```

### 第三部分

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f61366b80014401bc82f70ad3e25f2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:70%;" />

之前我也有疑惑，为什么原型对象的上一级是`Obejct.prototypr`？后来我理解了一句话：**原型对象也是对象**之后也就恍然大悟，看图上的`o1 o2`实例对象，它们是由构造函数`function Object()`创建而来，所以 o1 的`__proto__`和 Object 构造函数 的`prototype`指向`Object.prototype`原型对象。我们再来回味那句：**原型对象也是对象**，明白了吗？原型对象也是由构造函数`function Object()`创建而来，所以`Function.prototype` 和 `Foo.prototype` 的`__proto__`也指向`Object.prototype`

因为`Obejct.prototype`也是对象，所以也有`__proto__`属性，但是它没有上级了，所以`Obejct.prototype.__proto__ = null`，这里我就一起表示出来了

## 合并

再把上面画的图合并起来，再来看这张组传图谱是不是清晰了很多？

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b2988961fb44e8f941f3606a2ed9efe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:75%;" />

### constructor

另外，`constructor`这个属性我从头到尾都没有提到过，`constructor`这个属性是原型对象指回构造函数的，并且这属性值可以被修改

```jsx
f1.__proto__.constructor;
// ƒ Foo(name) {
//    this.name = name
//}

f1.__proto__.constructor = ''; // ""
```

比如，想要通过实例找到构造函数，那么可以：

```jsx
new Date().__proto__.constructor; // ƒ Date() { [native code] }
```

先找到原型对象，再通过原型对象的 `constructor` 属性定位到构造函数

## 应用场景
