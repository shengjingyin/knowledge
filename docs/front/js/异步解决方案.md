> 原文连接: https://github.com/sisterAn/blog/issues/29

在发送异步请求时，ES6 诞生以前，异步编程的方法，大概有下面四种。

- 回调函数
- 事件监听
- 发布/订阅
- Promise 对象

之前我们常用 ajax，当多个异步请求有嵌套关系时，容易产生回调地狱现象，如下：

```js
ajax('XXX1', () => {
  // callback 函数体
  ajax('XXX2', () => {
    // callback 函数体
    ajax('XXX3', () => {
      // callback 函数体
    });
  });
});
```

虽然回调函数在我们聪明的前端手中不算个难点，能够解决异步获取数据的顺序问题，但是也是实实在在的增加了心智负担，由于嵌套深，难于理解、可读性差。

## Promise

在 ES6 时期新增了 Promise，专门用来解决回调地狱。Promise 实现了链式调用，也就是说每次 then 后主动返回的一个全新 Promise，之后就可以继续使用 `.then` 来接收前面异步数据。

```js
new Promise(resolve => {
  ajax('XXX1', () => {
    resolve('消息1');
  });
})
  .then(res => {
    // 操作逻辑
    return new Promise(resolve => {
      ajax('XXX1', () => {
        resolve('消息2');
      });
    });
  })
  .then(res => {
    // 操作逻辑
    return new Promise(resolve => {
      ajax('XXX1', () => {
        resolve('消息4');
      });
    });
  });
```

借助 Promise 可以把 回调地狱 的问题处理掉，但同时也发现单纯的使用 Promise 的写法太长了

## Generator 与 Promise 结合

使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个 Promise 对象。在执行主体中，异步任务按顺序执行，具体任务通过 run 函数持续推进 generator 函数的 next 方法，直到结束

```js{6,8-9,14-25}
function asyncFunc<T>(v: T): Promise<T> {
  return new Promise((resolve, reject) => {
    resolve(v);
  });
}
const g = function* () {
  try {
    const foo = yield asyncFunc(12);
    const foo2 = yield asyncFunc('foo');
  } catch (error) {
    console.log('🚀 ~ file: index.vue ~ line 20 ~ error', error);
  }
};
function run(generator: GeneratorFunction) {
  const it = generator();
  function go(result) {
    if (result.done) return result.value;

    return result.value.then(
      res => go(it.next(res)),
      error => go(it.throw(error))
    );
  }
  go(it.next());
}

run(g);
```

## async/await

ES2017 引入 async，本质是 Generator 函数的语法糖。 async 函数对 Generator 函数的改进，体现在以下四点。

- **内置执行器**

- **更好的语义**

- **更广的适用性**

- **返回值是 Promise**

```js
async function test() {
  await fetch('XXX1');
  await fetch('XXX2');
}
```

### await 练习题

```js {4}
let a = 0;
let b = async () => {
  console.log('0', a); // -> '0' 0
  a = a + (await 10);
  console.log('2', a); // -> '2' 10
};
b();
a++;
console.log('1', a); // -> '1' 1
```

原因:

- 执行 b 时，会先执行同步部分，输出 `'0' 0`

- 因为 b 含有异步函数，所以会把异步任务推入异步队列中，执行主线程同步部分，即执行 log1，此时输出 `'1' 1`

- 继续执行函数 `b` 异步部分，在执行到 `await 10` 之前（步骤 1）变量 `a` 还是 0，因为 `await` 内部实现了 `generator` ，**`generator` 会保留堆栈中状态，所以这时候 `a = 0` 被保存了下来**

- 此时输出 log2 `a = 0 + 10`，`'2' 10`

```js{4}
let a = { age: 0 };
let b = async () => {
  console.log('0', a.age); // -> '0' 0
  a.age = a.age + (await 10);
  console.log('2', a.age); // -> '2' 10
};
b();
a.age++;
console.log('1', a.age); // -> '1' 1
```

原因：由于 await 内部保存了状态快照，所以输出仍是 10
