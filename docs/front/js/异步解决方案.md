得益于 ES6 的`Promise` 与 ES7 的`async、await` 可以使异步更简洁，在发送异步请求时，之前我们常用 ajax，当多个异步请求有嵌套关系时，容易产生回调地狱现象，如下：

```js
ajax('XXX1', () => {
  // callback 函数体
  ajax('XXX2', () => {
    // callback 函数体
    ajax('XXX3', () => {
      // callback 函数体
    });
  });
});
```

虽然回调函数在我们聪明的前端手中不算个难点，能够解决异步获取数据的顺序问题，但是也是实实在在的增加了心智负担，由于嵌套深，难于理解、可读性差。

## 2、Promise

在 ES6 时期新增了 Promise，专门用来解决回调地狱。Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装

```js
new Promise(resolve => resolve('消息1'))
  .then(res => {
    console.log('🚀 ~ file: 异步解决方案.md ~ line 24 ~ res', res);
    // 操作逻辑
    return new Promise(resolve => resolve('消息2'));
  })
  .then(res => {
    console.log('🚀 ~ file: 异步解决方案.md ~ line 24 ~ res', res);
    // 操作逻辑
    return new Promise(resolve => resolve('消息3'));
  })
  .then(res => {
    // 操作逻辑
    console.log('🚀 ~ file: 异步解决方案.md ~ line 24 ~ res', res);
    return new Promise(resolve => resolve('消息4'));
  });
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e90afaeab9234138bf4d8c9c8a7fafb8~tplv-k3u1fbpfcp-watermark.image?)

优点：

- 解决了回调地狱的问题

缺点：

- 太长

### 3、Generater

特点：

- 可以控制函数的执行，可以配合 co 函数库使用

```js
function* fetch() {
  yield ajax('XXX1', () => {});
  yield ajax('XXX2', () => {});
  yield ajax('XXX3', () => {});
}
let it = fetch();
let result1 = it.next();
let result2 = it.next();
let result3 = it.next();
```

### 4、Async/await

优点：

- **代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题**
- 代码量少

缺点：

- 将异步代码改造成同步代码，如果各个异步模块没有依赖（前后）关系，那么会影响性能

```js
async function test() {
  // ** 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
  // 如果有依赖性的话，其实就是解决回调地狱的例子了
  await fetch('XXX1');
  await fetch('XXX2');
  await fetch('XXX3');
}
```

### await 练习题

```js
let a = 0;
let b = async () => {
  a = a + (await 10);
  console.log('2', a); // -> '2' 10
};
b();
a++;
console.log('1', a); // -> '1' 1
```

原因:

- 首先函数 `b` 先执行，在执行到 `await 10` 之前变量 `a` 还是 0，因为 `await` 内部实现了 `generator` ，**`generator` 会保留堆栈中东西，所以这时候 `a = 0` 被保存了下来**
- 因为 `await` 是异步操作，后来的表达式不返回 `Promise` 的话，就会包装成 `Promise.reslove(返回值)`，然后会去执行函数外的同步代码
- 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 `a = 0 + 10`

上述解释中提到了 `await` 内部实现了 `generator`，其实 `await` 就是 `generator` 加上 `Promise`的语法糖，且内部实现了自动执行 `generator`。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。

> 原文连接（https://github.com/sisterAn/blog/issues/29）
