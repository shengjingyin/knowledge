## 原文

[深拷贝的终极探索（99%的人都不知道）](https://segmentfault.com/a/1190000016672263)

文章介绍了`clone` 的多个版本，以及着重解决两个问题：循环引用 和 爆栈 问题解决方案，目前来看

[ √ ] 循环引用

[ x ] 爆栈

## 为什么需要拷贝

说到深浅拷贝前，先来看两个现象，关于**基本类型**和**引用类型**的赋值，看看有什么奇怪的事情发生

- 基本类型进行`=`号运算时，现象和我们常理是相同的，不存在异样

  ```js
  let a = 1;
  let b = a;
  b = 2; // a: 1	 b: 2
  ```

- 引用类型进行`=`号运算就出现问题了，贴代码

  ```js{3}
  let c = { name: 'shengjingyin' };
  let d = c;
  d.name = 'juliya'; // c:  {name: "juliya"}	d:  {name: "juliya"}
  ```

这是什么情况，我明明只是重新定义了`d.name`对吧？为什么`c`也跟着一起改变了？

原来啊，这和**引用类型的存储方式有关**，再来重温一下这张引用类型的数据存储方式，在进行`let d = c;`时，实际上是将 c 在栈中存储指向堆中的地址赋值给了 d，所以 c、d 指向同一个对象。

  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7de80a37e3084c1292ebfd55eba059c3~tplv-k3u1fbpfcp-zoom-1.image" style="zoom: 50%;" />

所以当我改变`d.name`时，`c.name`也受到影响

 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e15d735f46b440e91a7f055cb24cf64~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

基于这种现象，有时候我们在开发中，需要的是两个互不关联且属性值相等的对象，这时候就是出现拷贝的意义了。

## 深拷贝 & 浅拷贝

深浅拷贝的出现，就是为了解决上述问题，那么为何有两种拷贝呢？它们也是有着细微差别

先来看一个浅拷贝的一个实例，和上面的例子一样（这里先不要在意深浅拷贝是什么，后面会有总结）

```js
let c = { name: 'shengjingyin' };
let d = Object.assign({}, c); // ES6方法
d.name = 'juliya'; // c:  {name: "shengjingyin"}	d:  {name: "juliya"}
```

这下完美解决了，`c`和`d`的关联完全被断开了，可以开开心心的继续开发了，可是.....再来看一个代码

```js
let c = { name: 'shengjingyin', habit: ['篮球', '游泳'] };
let d = Object.assign({}, c);
d.name = 'juliya';
d.habit.push('code');
```

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5da48df25ee459590fa28777af65312~tplv-k3u1fbpfcp-watermark.image?)

可以看到！！！爱好这一栏又出现关联了！！！

那么....接下来就是深拷贝的闪亮出场时刻了

```js
let c = { name: 'shengjingyin', habit: ['篮球', '游泳'] };
let d = JSON.parse(JSON.stringify(c)); //ES5
d.habit.push('code');
```

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c970399cd288461187a9086db5c04e5c~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

这下又断开关联了!

通过上面的两个列子，我们可以知道深浅拷贝的区别在于：**对于嵌套的复杂数据类型，能否做到剪断相关的关联信息**。

### 概念总结

- 浅拷贝：可以理解为进行简单的拷贝，对于对象**第一层的元素的属性值**是基本类型的，完全复制；对于**第一层的元素的属性值**是引用类型的赋值的是引用类型的内存地址，而不是实体，所以还是会出现复制前后关联的问题；
- 深拷贝：对于深拷贝，那就是可以理解为不管对象嵌套多深，经过拷贝之后前后两者的关联都被剪断了，互不影响，相互独立。

总的来说，两者主要的区别是：对于**第一层的属性为引用类型数据**进行复制的时候，复制的是数据的**引用**还是**实例**，是引用则为浅拷贝，反之深拷贝。

---

## 实现深浅拷贝

前面已经介绍过实现深浅拷贝的各一个方式`Object.assign({}, c)`、`JSON.parse(JSON.stringify(c))`，这里也将继续实践其他种类的深浅拷贝

### 浅拷贝

#### `Array.prototype.slice()` 和 `Array.prototype.concat()`

利用的是这两个方法返回新数组的特性进行浅拷贝**数组**（因为这两个方法是数组的方法 😂）

```js
let a = [[1, 2], 2, 3, 4];
let b = a.slice(); // < 等-价 >   let b = a.concat()
b[0][0] = 10;
b[1] = 20;
```

a、b 的结果如下图，可以看出，和我前文提到的浅拷贝怪异的现象一致，第一层复制的是实体，第二层复制的是引用，所以`b[1]`改变时，`a[1]`未改变；`b[0][0]`改变时，`a[0][0]`也跟着改变

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a6af234c0144d188ebdb9e17cf379a1~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

#### 遍历

```js
function cloneObj(traget) {
  let ret = {};
  for (let key in target) {
    ret[key] = target[key];
  }
  return ret;
}
```

#### `Object.assign`

```js
let obj = {
  name: 'shengjingyin',
  cc: {
    name: 'juliya',
  },
};
let newObj = Object.assign({}, obj);

obj.name = 'juliya';
obj.cc.name = 'juliya';
```

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/456f354fe44346d4a7cdace043c5b43e~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

#### 扩展运算符

```js
let newObj = { ...obj };
//--------对于数组也是一样的-------
let oldArr = [[1, 2], 2, 3, 4];
let newArr = [...oldArr];
```

### 深拷贝

前文减少过 `JSON.parse(JSON.stringify( target ))` 以这种形式进行深拷贝，通常情况下可以正常拷贝，但该方法也有一些弊端：

### 递归

简单版递归深拷贝，主要思路：判断值是否为对象，是对象的话需要进行递归调用

```js{6}
function cloneDeep(source) {
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (typeof source[key] === 'object') {
        target[key] = cloneDeep1(source[key]); // 注意这里
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
}
```

递归版本存在嵌套引用时，会爆栈，改用遍历可以解决

### 遍历

解决两个问题：

- 循环引用

```js {5}
const b = 1;
const origin = { a1: b, a2: b };
const newData = cloneDeep2(origin);

newData.a1 === newData.a2; // true
```

- 爆栈

这个问题经过递归改造成遍历，目前来看也没有解决爆栈问题

源码

```ts {7,39,24-33}
const cloneDeep = <T extends Object>(source: T): T => {
  // 判断是否循环引用
  const unique: UniQue[] = [];
  // 结果
  const root: T = {};
  // 栈
  const loopList: TreeNode[] = [
    {
      parent: root,
      key: undefined,
      data: source,
    },
  ];

  while (loopList.length) {
    const node = loopList.pop() as TreeNode;
    const { parent, key, data } = node;
    let res = parent;

    if (key !== undefined) {
      res = parent[key] = {};
    }

    const uniqueData = unique.find(item => item.source === data);
    if (uniqueData && key) {
      parent[key] = uniqueData.target;
      break;
    } else {
      unique.push({
        source: data,
        target: res,
      });
    }

    for (const k in data) {
      if (Object.prototype.hasOwnProperty.call(data, k)) {
        const element = data[k];
        if (typeof element === 'object') {
          loopList.push({
            parent: res,
            key: k,
            data: data[k],
          });
        } else {
          res[k] = data[k];
        }
      }
    }
  }
  return root;
};
```
