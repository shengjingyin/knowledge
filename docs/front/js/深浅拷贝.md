# js 深浅拷贝你知道多少？

# [深拷贝的终极探索（99%的人都不知道）](https://segmentfault.com/a/1190000016672263)

在 js 引擎中对变量的存储主要有两种位置，**堆内存和栈内存**，这两位分工合作，分别保管 JS 中的两种数据类型：基本数据类型和复杂数据类型

## 一、数据类型

要知道堆栈，首先我们先了解下 ECMAScript 数据类型，数据类型整体可分为两种**基本数据类型** & **复杂数据类型**：

-   基本类型：Number、String、Boolean、null、undefined、Symbol；
-   复杂类型：Object（Object、Array、function、Date、RegExp）。

相信这两种数据类型大家都太常见了，开发中随便`let`一个变量就是两种类型之一，那么我们声明变量之后是如何进行存储的呢？

在 js 引擎中对变量的存储主要有两种位置，**堆内存和栈内存**，不同类型的数据存储方式不同，总结两句话如下：

-   基本类型：基本类型值在内存中占据固定大小，保存在**栈内存**中
-   引用类型：引用类型的值是**对象**，保存在**堆内存**中，而**栈内存**存储的是**对象的变量标识符**以及**对象在堆内存中的存储地址**

上面两句话我将引入两张图来助大家理解

-   基本数据类型存储方式

    ```
    let a = 1;
    let b = true;
    let c = null;
    复制代码
    ```

    当我声明三个基本数据类型的变量时，**栈内存**存储变量的方式类似下图所示保存在栈内存中，基本数据类型占用空间小、大小固定，通过值来访问。

    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc644312d6624a3eb3fc7c5655a240d0~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210813214521711.png" style="zoom:50%;" />

-   复杂数据类型存储方式

    ```
    let obj = {}；
    let arr = [];
    let map = new Map();
    复制代码
    ```

    当我声明了以上三个复杂数据类型时，**栈、堆内存**存储变量的方式类似下图所示，在栈内存中存取的是数据实体的引用地址，这个应用地址能够从堆内存中找到对应的实体数据，解释器寻找复杂数据类型时，需要先获取栈中的地址，取得地址后，再从堆中获得实体数据

    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4cc819b696240b88a79f7a3317f2af4~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210815205530589.png" style="zoom:50%;" />

    这里的栈内存存储的是复制数据类型的**引用地址**，可以在堆内存中通过这个引用地址获取到对应的复杂数据类型

---

## 二、天降异象

说到深浅拷贝前，先来看两个现象，关于**基本类型**和**引用类型**的赋值，看看有什么奇怪的事情发生

-   基本类型进行`=`号运算时，现象和我们常理是相同的，不存在异样

    ```js
    let a = 1;
    let b = a;
    b = 2; // a: 1	 b: 2
    ```

-   引用类型进行`=`号运算就出现问题了，贴代码

    ```js
    let c = { name: "shengjingyin" };
    let d = c;
    d.name = "juliya"; // c:  {name: "juliya"}	d:  {name: "juliya"}
    ```

    这是什么情况，我明明只是重新定义了`d.name`对吧？为什么`c`也跟着一起改变了？

    原来啊，这和**引用类型的存储方式有关**，再来重温一下这张引用类型的数据存储方式。

    <img src="D:\Project\image-host\img/image-20210816201339057.png" style="zoom: 50%;" />

    看到没有！引用类型的值是**对象**，保存在**堆内存**中，而**栈内存**存储的是**对象的变量标识符**以及**对象在堆内存中的存储地址**，`d`经过赋值后，其实是和`c`的引用地址一样，他们开启堆中实体的"钥匙"是一模一样的，对象本质上是同一个。所以当我改变`d.name`时，`c.name`也受到影响

    <img src="D:\Project\image-host\img/image-20210816201633224.png" style="zoom:50%;" />

## 三 、深拷贝 & 浅拷贝

深浅拷贝的出现，就是为了解决这一问题，那么为何有两种拷贝呢？它们也是有着细微差别

先来看一个浅拷贝的一个实例，和上面的例子一样（这里先不要在意深浅拷贝是什么，后面会有总结）

```js
let c = { name: "shengjingyin" };
let d = Object.assign({}, c); // ES6方法
d.name = "juliya"; // c:  {name: "shengjingyin"}	d:  {name: "juliya"}
```

这下完美解决了，`c`和`d`的关联完全被断开了，可以开开心心的继续开发了，可是.....再来看一个代码

```js
let c = { name: "shengjingyin", habit: ["篮球", "游泳"] };
let d = Object.assign({}, c);
d.habit.push("code");
```

<img src="D:\Project\image-host\img/image-20210816202642485.png" style="zoom:50%;" />

可以看到！！！爱好这一栏又出现关联了！！！还让不让人写代码了！

那么....接下来就是深拷贝的闪亮出场时刻了

```js
let c = { name: "shengjingyin", habit: ["篮球", "游泳"] };
let d = JSON.parse(JSON.stringify(c)); //ES5
d.habit.push("code");
```

<img src="D:\Project\image-host\img/image-20210816203032204.png" style="zoom:50%;" />

这下又断开关联了！舒服

通过上面的几个列子，知道深浅拷贝的作用了嘛？其实就是**引用类型进行`=`号运算时，会产生一些奇怪的关联现象，这时我们需要特殊处理下，剪断它们两者之间的关联**，这就是深浅拷贝的意义所在！！！

### 3.1 概念总结

-   浅拷贝：可以理解为进行简单的拷贝，对于对象**第一层的元素的属性值**是基本类型的就相当于是基本类型的`=`号运算，完全复制；对于**第一层的元素的属性值**是引用类型的相当于还是引用类型的`=`号运算，这样子复制的还是引用类型的内存地址，而不是实体，所以还是会出现前后关联的问题；
-   深拷贝：对于深拷贝，那就是可以理解为不管第几层，两者的关联都被剪断了，这前后两个数据没有任何关联，互不影响，相互独立。

> 总的来说，两者主要的区别是：对于**第一层的属性为引用类型数据**进行复制的时候，复制的是数据的**引用**还是**实例**，是引用则为浅拷贝，反之深拷贝

---

## 四、实现深浅拷贝

前文已经介绍过实现深浅拷贝的各一个方式`Object.assign({}, c)`、`JSON.parse(JSON.stringify(c))`（乞丐版），本文也将继续实践其他种类的深浅拷贝

### 4.1 浅拷贝

对于浅拷贝一般都是一行代码就行了，比较实现的目的比较单纯，只需要第一层为实体复制即可，主要分为两大阵营，一类是远古时期，一类是现代文明。

#### 远古时期

其实现在也在用，没那么老 😂，只是实现方式没那么现代，代码比较长。。。

##### 4.1.1 `Array.prototype.slice()` 和 `Array.prototype.concat()`

利用的是这两个方法返回新数组的特性进行浅拷贝**数组**（因为这两个方法是数组的方法 😂）

```js
let a = [[1, 2], 2, 3, 4];
let b = a.slice(); // < 等-价 >   let b = a.concat()
b[0][0] = 10;
b[1] = 20;
```

a、b 的结果如下图，可以看出，和我前文提到的浅拷贝怪异的现象一致，第一层复制的是实体，第二层复制的是引用，所以`b[1]`改变时，`a[1]`未改变；`b[0][0]`改变时，`a[0][0]`也跟着改变，详情可看我前文[详细理解深浅拷贝存在的意义！！！](https://juejin.cn/post/6997040481867661343)

<img src="D:\Project\image-host\img/image-20210817222056963.png" style="zoom:50%;" />

##### 4.1.2 对象浅拷贝

没有找到相关比较老的方法实现，可以使用函数循环遍历实现

```js
function cloneObj(traget) {
    let ret = {};
    for (let key in target) {
        ret[key] = target[key];
    }
    return ret;
}
```

#### 现代文明

主要以 ES6 中的两种方式可以实现，一个是`Object.assign`、一个是`扩展运算符`

##### 4.1.3 `Object.assign(target, ...sources)`

```js
let obj = {
    name: "shengjingyin",
    cc: {
        name: "juliya",
    },
};
let newObj = Object.assign({}, obj);

obj.name = "juliya";
obj.cc.name = "juliya";
```

<img src="D:\Project\image-host\img/image-20210817223135728.png" style="zoom:50%;" />

##### 4.1.4 ...扩展运算符

与上面唯一的不同就是`=`号运算时不同，结果完全一样，这才是现代化好吗，简洁舒适通用。

```js
let newObj = { ...obj };
//--------对于数组也是一样的-------
let oldArr = [[1, 2], 2, 3, 4];
let newArr = [...oldArr];
```

浅拷贝介绍了远古时期和现代文明的几种方式，要我选的话我会推荐后两种，特别是扩展运算符

### 4.2 深拷贝

深拷贝的实现的方式也有很多种（主要思想是递归）

#### 4.2.1 `JSON.parse(JSON.stringify( target ))`

```js
let a = [[1, 2], 2, 3, 4];
let b = JSON.parse(JSON.stringify(a));
a[0][0] = 5;
a[1] = 20;
```

结果如下，多层数据均为复制实体，前后无关联

<img src="D:\Project\image-host\img/image-20210817223945358.png" style="zoom:50%;" />

#### 4.2.2 递归

简单版递归深拷贝，主要思路：判断值是否为对象，是对象的话需要进行递归调用

```js
function cloneDeep1(source) {
    var target = {};
    for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (typeof source[key] === "object") {
                target[key] = cloneDeep1(source[key]); // 注意这里
            } else {
                target[key] = source[key];
            }
        }
    }
    return target;
}
```
