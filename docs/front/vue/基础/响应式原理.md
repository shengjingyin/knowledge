# vue 响应式原理

vue 响应式原理基于数据劫持 （`Object.defineProperty`），通过 该 方法的 get 和 set 方法实现获取 数据和数据改变时做出的相应的响应变化。

数据初始化时，添加观察者把 data 中所有的数据都循环添加进 `Object.defineProperty` 中 进行数据监听 （当然有对象和数组的数据需要深度监听，特殊处理），普通数据此时修改可以响应式的变化（在 set 回调函数中响应变化），代码如下：

```js
let data = {
    name: "juliya",
    age: 18,
    friend: {
        name: "朱丽燕",
    },
    color: ["pink", "black", "white"],
};

observe(data);

function observe(target) {
    if (typeof target !== "object" || target === null) {
        return target;
    }

    for (const key in target) {
        defineReactive(target, key, target[key]);
    }
}
// 数据劫持
function defineReactive(target, key, value) {
    Object.defineProperty(target, key, {
        get: function() {
            return value;
        },
        set(newValue) {
            if (newValue !== value) {
                value = newValue;
                console.log("更新了视图111111111111111");
            }
        },
    });
}
```

## 对于对象进行深度监听

只需要调用观察函数即可

```js
function defineReactive(target, key, value) {

    observe(value)		// 如果value是对象 则会继续调用 数据劫持函数

    ....数据劫持操作

    Object.defineProperty(target, key, {
        get: function () {
            return value
        },
        set(newValue) {
            observe(newValue);	//  这里是对新值也添加进监听对象中
            if (newValue !== value) {
                value = newValue
                console.log('更新了视图111111111111111')
            }
        }
    })
}

```

## 对数组数据进行深度监听

需要更改 调用数组方法时的处理函数，在原生数组函数的基础上再调用更新的函数

```js
// 实现调用数组方法更新视图
const oldArrayProto = Array.prototype;
const newArrayProto = Object.create(oldArrayProto);

["push", "pop", "shift", "unshift", "splice"].forEach((methodsName) => {
    newArrayProto[methodsName] = function() {
        console.log("更新了视图22222222222");
        oldArrayProto[methodsName].call(this, ...arguments);
    };
});
```

将数组的`__proto__`指向改为我们设定好的处理函数

```js
function observe(target) {
	...基础数据操作

    if (Array.isArray(target)) {
        target.__proto__ = newArrayProto
    }

    ...对象数据操作

}
```

## 完整代码

```js
let data = {
    name: "juliya",
    age: 18,
    friend: {
        name: "朱丽燕",
    },
    color: ["pink", "black", "white"],
};

// 实现调用数组方法更新视图
const oldArrayProto = Array.prototype;
const newArrayProto = Object.create(oldArrayProto);

["push", "pop", "shift", "unshift", "splice"].forEach((methodsName) => {
    newArrayProto[methodsName] = function() {
        console.log("更新了视图22222222222");
        oldArrayProto[methodsName].call(this, ...arguments);
    };
});

observe(data);

function observe(target) {
    if (typeof target !== "object" || target === null) {
        console.log("target", target);
        return target;
    }

    if (Array.isArray(target)) {
        target.__proto__ = newArrayProto;
    }

    for (const key in target) {
        defineReactive(target, key, target[key]);
    }
}

function defineReactive(target, key, value) {
    observe(value);
    Object.defineProperty(target, key, {
        get: function() {
            return value;
        },
        set(newValue) {
            observe(newValue);
            if (newValue !== value) {
                value = newValue;
                console.log("更新了视图111111111111111");
            }
        },
    });
}
// data.age = { number: 20 }
// data.age.number = '444'
// data.color[0] = 'green'
data.friend.name = 10;
// data.color.push('green')
```
