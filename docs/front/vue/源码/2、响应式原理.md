# 响应式原理 、双向绑定原理

## 响应式原理

<img src="https://gitee.com/sjy666666/image-host/raw/master/img/image-20220321222242944.png" alt="image-20220321222242944" style="zoom:80%;" />

> /src/core/instance/state.js

```js
export function initState(vm: Component) {
  vm._watchers = [];
  const opts = vm.$options;
  // 1、为每个props 设置响应式，2、代理，将this.props上的属性代理到vm实例上
  if (opts.props) initProps(vm, opts.props);
  // 1、判重处理，props名称优先级 > methods，2、将methods代理到当前组件实例
  if (opts.methods) initMethods(vm, opts.methods);
  if (opts.data) {
    // 1、校验data，确保最终返回的是一个对象
    // 2、判重处理，优先级：props > methods > data
    // 3、代理属性到vm实例上
    // 4、响应式处理observe
    initData(vm);
  } else {
    // 1、响应式处理observe
    observe((vm._data = {}), true /* asRootData */);
  }
  // 计算属性的本质也是一个watch实例，设置计算属性的get和set，代理计算属性到vm上
  if (opts.computed) initComputed(vm, opts.computed);
  /* Firefox has a "watch" function on Object.prototype... */
  /* 因为火狐的对象有watch属性，所以需要判断书不是原生的watch */
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
```

`initState 方法` 在初始化时，被`_init方法`调用，这里是响应式的入口，主要做了三件事：

- 初始化 Props（设置响应式`defineReactive方法`）

  - 检查
    - 检查系统保留字
  - 设置响应式`defineReactive方法`时，第四个参数设置 props ssetter，ssetter 检查是否子组件改变 props
  - 代理 props 属性到 vm 实例上

- 初始化 methods

  - 遍历 methods，检查 methods 是否合法：
    - 判断是不是函数
    - 判断 key 是否在 props 中已经使用过了
    - 判断 key 是不是以\_ or \$ 开头
  - 设置方法到实例上

- 初始化 data

  - 获取 data 后（兼容函数形式与对象形式），判断获取到的结果是不是`object`
  - 循环 keys 判重：
    - 看 key 是否被 methods 使用过
    - 看 key 是否被 props 使用过
  - 代理 data 中的 key 到 vm 实例上
  - 调用`observe(data, true /* asRootData */)`，监测对象

- 初始化 computed

  - 遍历 computed

    - 检查是否存在`getter`

    - 创建内部 watcher 给 computed 属性

      > computed 的本质也是一个 watcher，只不过是内部的

      ```js
      const computedWatcherOptions = { lazy: true }; // 惰性观察者
      const watchers = (vm._computedWatchers = Object.create(null));
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
      ```

    - 检查 vm 实例是否存在过 computed key

      - 不存在，调用`defineComputed方法`

        - 兼容 computed 为函数或者对象形式，设置对应的 getter 和 setter

        - 使用`Object.defineProperty`拦截计算属性的访问和修改

          ```js
          const sharedPropertyDefinition = {
            enumerable: true,
            configurable: true,
            get: noop,
            set: noop,
          };

          sharedPropertyDefinition.get = shouldCache
            ? createComputedGetter(key)
            : createGetterInvoker(userDef);
          sharedPropertyDefinition.set = noop;
          ```

      Object.defineProperty(target, key, sharedPropertyDefinition);

          ```

      - 存在，则依次对 data、props、methods 进行判重

- 初始化 watcher

  - 遍历每一个 watcher 调用`createWatcher(vm, key, handler);`
  - 调用`vm.$watch(expOrFn, handler, options)`
  - 标记为用户 watcher `options.user = true;`
  - 调用观察者：`const watcher = new Watcher(vm, expOrFn, cb, options);`
  - 在 watcher 构造函数中，因为 lazy 为 false，所以会去调用 getter，进行依赖收集

## data 响应式处理

- observe(data, true /_ asRootData _/);

- ob = new Observer(value)

- this.observeArray(value) 、 this.walk(value)

- defineReactive(obj, keys[i])

  ```js
  /**
   * Define a reactive property on an Object.
   */
  export function defineReactive(
    obj: Object,
    key: string,
    val: any,
    customSetter?: ?Function,
    shallow?: boolean
  ) {
    const dep = new Dep();

    const property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return;
    }

    // cater for pre-defined getter/setters
    const getter = property && property.get;
    const setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
      val = obj[key];
    }

    let childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter() {
        const value = getter ? getter.call(obj) : val;
        // 什么时候设置的Dep.target？？？
        /* watch 进行getter操作时，会设置当前vm为Dep.target */
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value;
      },
      set: function reactiveSetter(newVal) {
        const value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || (newVal !== newVal && value !== value)) {
          return;
        }
        /* eslint-enable no-self-compare */
        if (process.env.NODE_ENV !== 'production' && customSetter) {
          customSetter();
        }
        // #7981: for accessor properties without setter
        if (getter && !setter) return;
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      },
    });
  }
  ```

## 提问

### computed 实现懒加载的原理是什么

计算属性的 getter 中关于 watcher 的计算函数有一个阀门就是`watcher.dirty`属性，当有数据更新时会调用`watcher.update`方法更新`dirty = true`，再次调用 getter 时就能通过这个`dirty`阀门，计算完值后就会缓存计算值，并且把`dirty`关闭，下次再调用 compute 属性时，只要数据没更新就不会去重新计算

```js
// watch.js
class Watcher {
  evaluate() {
    this.value = this.get();
    this.dirty = false;
  }
  update() {
    if (this.lazy) {
      this.dirty = true;
    }
  }
}
```

```js
// computedGetter
function computedGetter() {
  const watcher = this._computedWatchers && this._computedWatchers[key];
  if (watcher) {
    // dirty 代表依赖是否可被更新，数据没更新就不会进行evaluate计算
    // 当dirty为true时，标识可以进行watcher计算，每次计算完会将dirty置为false，标识已计算，当依赖数据改变时，会将该属性再次置为true，标识能够再次进行计算
    if (watcher.dirty) {
      // 做了两件事：1、将dirty置为false，响应式原理，2、调用get，获取值
      // evaluate 计算
      watcher.evaluate();
    }
    // 添加watcher依赖
    if (Dep.target) {
      watcher.depend();
    }
    return watcher.value;
  }
}
```

## computed 与 watcher 有什么区别

本质上都是**watcher**实例，

computed，为内部 watcher，并且具有缓存功能，只有当响应式依赖被调用时，才会把 watcher 的`dirty`属性置为`true`，重新计算；

watcher 监听某一个变量的变化，调用 handler 函数，可以执行异步操作，并且会被标记为用户 watcher
