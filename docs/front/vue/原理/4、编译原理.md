当初次渲染和更新时，执行每个 `watcher.run` 方法，由 run 方法 调用 `watcher.get` 方法，从而能执行 `getter`函数，最后进入更新阶段，组件更新时，执行的是 `updateComponent` 方法

```js
// /src/core/instance/lifecycle.js
const updateComponent = () => {
  // 执行 vm._render() 函数，得到 虚拟 DOM，并将 vnode 传递给 _update 方法，接下来就该到 patch 阶段了
  vm._update(vm._render(), hydrating);
};
```

每次更新前，会先运行`vm._render` 方法，这就是常说的 render 函数，由两种方式获得：

- 用户自己提供，在编写组件时，用 render 选项代替模版
- 由编译器编译组件模版生成 render 选项

编译器的过程主要有三个步骤：

- **解析**，类 HTML 模板解析为 AST 对象
- **优化**，也叫**静态标记**，变量 AST 对象，标记其中的静态节点、静态根节点
- **生成渲染函数**，将 AST 对象生成渲染函数

`vm._update`方法

---

#### baseCompile | 编译流程核心

`baseCompile`函数 主要安排了 编译的核心三步骤

- **解析**：将 html 模板字符串解析为 ast 对象
- **优化**：遍历 ast，标记静态节点和静态根节点
- **代码生成**：生成渲染函数 render

```tsx{9,12,15}
const createCompiler = createCompilerCreator(function baseCompile(
  template: string,
  options: CompilerOptions
): CompiledResult {
  // *执行baseCompile 之前做的都是 选项合并的工作，这里的options 是 finalOptions

  // !核心
  // *解析，将html模板字符串解析为 ast 对象
  const ast = parse(template.trim(), options);
  // *优化，遍历ast，标记静态节点和静态根节点
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  // *代码生成，生成渲染函数 render
  const code = generate(ast, options);
  // !compileToFunctions 最终结果
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns,
  };
});
```
