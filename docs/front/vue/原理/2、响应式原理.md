## 响应式原理

<img src="https://v2.cn.vuejs.org/images/data.png" style="zoom:80%;" />

当渲染时，会读取 data 中的属性，触发属性拦截器【getter】，在【getter】中会进行【依赖收集】，dep 保存所有相关的 watcher；当对属性进行设置时，会触发属性的【setter】，此时 dep 会调用所有的 watcher 进行【发布更新】。

## initState

`initState 方法` 在初始化时，被`_init方法`调用，这里是响应式的入口，主要做了一件事：初始化 Props【watcher】、methods、data【watcher】、computed【watcher】、watcher【watcher】

#### 源码

> /src/core/instance/state.js

- 初始化 Props

  - 检查名称是不是系统保留字
  - **设置响应式数据`defineReactive方法`时**，第四个参数设置 props setter，setter 检查是否子组件改变 props
  - 代理 props 属性到 vm 实例上

- 初始化 methods

  - 遍历 methods，检查 methods 是否合法：
    - 判断是不是函数
    - 判断 key 是否在 props 中已经使用过了
    - 判断 key 是不是以\_ or \$ 开头
  - 设置方法到实例上

- 初始化 data

  - 获取 data 后（兼容函数形式与对象形式），判断获取到的结果是不是`object`
  - 循环 keys 判重：
    - 看 key 是否被 methods 使用过
    - 看 key 是否被 props 使用过
  - 代理 data 中的 key 到 vm 实例上
  - **调用`observe(data, true /* asRootData */)`，对数据进行响应式处理**

- 初始化 computed

  - 遍历 computed

    - 检查是否存在`getter`

    - 创建内部 watcher 给 computed 属性

      > computed 的本质也是一个 watcher，只不过是内部的

      ```js{1,3}
      const computedWatcherOptions = { lazy: true }; // 惰性观察者
      const watchers = (vm._computedWatchers = Object.create(null));
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
      ```

    - 检查 vm 实例是否存在过 computed key

      - 不存在，调用`defineComputed方法`

        - 兼容 computed 为函数或者对象形式，设置对应的 getter 和 setter

        - 使用`Object.defineProperty`拦截计算属性的访问和修改

          ```js
          const sharedPropertyDefinition = {
            enumerable: true,
            configurable: true,
            get: noop,
            set: noop,
          };

          sharedPropertyDefinition.get = shouldCache
            ? createComputedGetter(key)
            : createGetterInvoker(userDef);
          sharedPropertyDefinition.set = noop;

          Object.defineProperty(target, key, sharedPropertyDefinition);
          ```

      - 存在，则依次对 data、props、methods 进行判重

- 初始化 watcher

  - 遍历每一个 watcher 调用`createWatcher(vm, key, handler);`
  - 调用`vm.$watch(expOrFn, handler, options)`
  - **标记为用户 watcher** `options.user = true;`
  - 调用观察者：`const watcher = new Watcher(vm, expOrFn, cb, options);`
  - 在 watcher 构造函数中，因为 lazy 为 false，所以会去调用 getter，进行依赖收集

```js{13}
export function initState(vm: Component) {
  vm._watchers = [];
  const opts = vm.$options;
  // 1、为每个props 设置响应式，2、代理，将this.props上的属性代理到vm实例上
  if (opts.props) initProps(vm, opts.props);
  // 1、判重处理，props名称优先级 > methods，2、将methods代理到当前组件实例
  if (opts.methods) initMethods(vm, opts.methods);
  if (opts.data) {
    // 1、校验data，确保最终返回的是一个对象
    // 2、判重处理，优先级：props > methods > data
    // 3、代理属性到vm实例上
    // 4、响应式处理observe
    initData(vm);
  } else {
    // 1、响应式处理observe
    observe((vm._data = {}), true /* asRootData */);
  }
  // 计算属性的本质也是一个watch实例，设置计算属性的get和set，代理计算属性到vm上
  if (opts.computed) initComputed(vm, opts.computed);
  /* Firefox has a "watch" function on Object.prototype... */
  /* 因为火狐的对象有watch属性，所以需要判断书不是原生的watch */
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
```

## 响应式处理

```js{15,20,24,38}
export function defineReactive(
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep();

  const property = Object.getOwnPropertyDescriptor(obj, key);

  const getter = property && property.get;
  const setter = property && property.set;

  let childOb = !shallow && observe(val); // 递归响应式处理
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      const value = getter ? getter.call(obj) : val;
      // 什么时候设置的Dep.target？？？
      /* watch 进行getter操作时，会设置当前vm为Dep.target */
      if (Dep.target) {
        dep.depend(); // 依赖收集
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      const value = getter ? getter.call(obj) : val;
      childOb = !shallow && observe(newVal); // 对新值进行递归响应式处理

      dep.notify(); // 发布更新
    },
  });
}
```

## 原理 computed

计算属性的 getter 中关于 watcher 的计算函数有一个阀门就是`watcher.dirty`属性，当有数据更新时会调用`watcher.update`方法更新`dirty = true`，再次调用 getter 时就能通过这个`dirty`阀门，get 计算完值后会把 `dirty` 阀门关闭，下次再调用 compute 属性时，只要响应式依赖数据没更新就不会去重新计算

```js{6-8}
function computedGetter() {
  const watcher = this._computedWatchers && this._computedWatchers[key];
  if (watcher) {
    // dirty 代表依赖是否可被更新，数据没更新就不会进行evaluate计算
    // 当dirty为true时，标识可以进行watcher计算，每次计算完会将dirty置为false，标识已计算，当依赖数据改变时，会将该属性再次置为true，标识能够再次进行计算
    if (watcher.dirty) {
      // 做了两件事：1、将dirty置为false，响应式原理，2、调用get，获取值
      watcher.evaluate();
    }
    // 添加watcher依赖
    if (Dep.target) {
      watcher.depend();
    }
    return watcher.value;
  }
}
```

```js {5,10}
// watch.js
class Watcher {
  evaluate() {
    this.value = this.get();
    this.dirty = false;
  }
  update() {
    if (this.lazy) {
      // computed都会标记lazy为true
      this.dirty = true;
    }
  }
}
```

## computed 与 watch 有什么区别

本质上都是**watcher**实例，

computed，为**内部 watcher**，并且具有缓存功能，只有当响应式依赖被调用时，才会把 watcher 的`dirty`属性置为`true`，重新计算；

watch 监听某一个变量的变化，调用 handler 函数，可以执行异步操作，并且会被**标记为用户 watcher**

#### watch

- 不支持缓存，响应式数据变，则会触发相应的操作；
- watch 支持异步
- 一个属性可以被多个 watcher 监听，一对多。
- 监听的数据必须是 data 中声明过的或者父组件传递过来的 props 中的数据
  - immediate：组件加载立即触发回调函数执行
  - deep：深度监听，为了发现复杂数据类型内部值的变化，监听数组的变化不需要（必须要用更改原数组的方法去更改才能监听到）。注意：deep 无法监听到数组的变动及对象的新增，只有以响应式的方式去改变才能监听到数值变化.

#### computed

- 支持缓存，只有依赖的数据发生变化时，才会重新计算
- 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化
- computed 计算属性是一个多对一或者一对一的情况，是由其他属性计算而来（一个或者多个），多对一。
- 如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中，属性都有一个 get 和 set 方法，当数据变化时，调用 set 方法

|      | watch | computed |
| ---- | ----- | -------- |
| 缓存 | ×     | √        |
| 异步 | √     | ×        |

## 实现响应式原理

```js{18}
let data = {
  name: 'juliya',
  age: 18,
  friend: {
    name: '朱丽燕',
  },
  color: ['pink', 'black', 'white'],
};

observe(data);

function observe(target) {
  if (typeof target !== 'object' || target === null) {
    return target;
  }

  for (const key in target) {
    defineReactive(target, key, target[key]);
  }
}
// 数据劫持
function defineReactive(target, key, value) {
  Object.defineProperty(target, key, {
    get: function () {
      return value;
    },
    set(newValue) {
      if (newValue !== value) {
        value = newValue;
        console.log('更新了视图111111111111111');
      }
    },
  });
}
```

- 对于对象进行深度监听

```js{2}
function defineReactive(target, key, value) {
  observe(value); // 如果value是对象 则会继续调用 数据劫持函数

  Object.defineProperty(target, key, {
    get: function () {
      return value;
    },
    set(newValue) {
      observe(newValue); //  这里是对新值也添加进监听对象中
      if (newValue !== value) {
        value = newValue;
        console.log('更新了视图111111111111111');
      }
    },
  });
}
```

- 对数组数据进行深度监听

当有响应式数据值是数组时，会**更改这个数组的原型链到 vue 重写好的数组方法上**，这样当不在框架内调用数组方法也是正常的

```js{5-11}
// 实现调用数组方法更新视图
const oldArrayProto = Array.prototype;
const newArrayProto = Object.create(oldArrayProto);

['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'sort'].forEach(methodsName => {
  newArrayProto[methodsName] = function () {
    // 数据响应式处理
    console.log('更新了视图22222222222');
    // 调用数组原方法
    oldArrayProto[methodsName].call(this, ...arguments);
  };
});
```

将数组的`__proto__`指向改为我们设定好的处理函数

```js
function observe(target) {
	...基础数据操作

    if (Array.isArray(target)) {
        target.__proto__ = newArrayProto
    }

    ...对象数据操作

}
```

## 完整代码

```js
let data = {
  name: 'juliya',
  age: 18,
  friend: {
    name: '朱丽燕',
  },
  color: ['pink', 'black', 'white'],
};

// 实现调用数组方法更新视图
const oldArrayProto = Array.prototype;
const newArrayProto = Object.create(oldArrayProto);

['push', 'pop', 'shift', 'unshift', 'splice'].forEach(methodsName => {
  newArrayProto[methodsName] = function () {
    console.log('更新了视图22222222222');
    oldArrayProto[methodsName].call(this, ...arguments);
  };
});

observe(data);

function observe(target) {
  if (typeof target !== 'object' || target === null) {
    return target;
  }

  if (Array.isArray(target)) {
    target.__proto__ = newArrayProto;
  }

  for (const key in target) {
    defineReactive(target, key, target[key]);
  }
}

function defineReactive(target, key, value) {
  observe(value);
  Object.defineProperty(target, key, {
    get: function () {
      return value;
    },
    set(newValue) {
      observe(newValue);
      if (newValue !== value) {
        value = newValue;
        console.log('更新了视图111111111111111');
      }
    },
  });
}
// data.age = { number: 20 }
// data.age.number = '444'
// data.color[0] = 'green'
data.friend.name = 10;
// data.color.push('green')
```
