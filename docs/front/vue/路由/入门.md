Vue Router 是 [Vue.js](http://cn.vuejs.org/) 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：

- 嵌套的路由/视图表
- 模块化的、基于组件的路由配置
- **路由参数、查询、通配符**
- 基于 Vue.js 过渡系统的视图过渡效果
- 细粒度的导航控制
- 带有自动激活的 CSS class 的链接
- HTML5 历史模式或 hash 模式，在 IE9 中自动降级
- 自定义的滚动条行为

## 文件配置

#### index.js 实例

```javascript
import Vue from 'vue';
import VueRouter from 'vue-router';
import routes from './router.js'; // 引入的路由匹配文件

Vue.use(VueRouter);

const router = new VueRouter({
  // 创建 router 实例
  mode: 'history',
  base: process.env.BASE_URL, // 当在 history 模式下使用 `base` 选项之后， 所有的 `to` 属性都不需要再写**基准路径** 了
  routes,
});

export default router;
```

#### route 实例

```javascript
export default [
  {
    path: '/tools',
    name: 'tools',
    component: () => import('../views/Tools.vue'),
    // 嵌套路由
    children: [{ path: 'fronted', component: () => import('../views/ToolsPage/fronted.vue') }],
  },
  // 捕获所有路由
  { path: '*', name: 'home', component: () => import('../views/Home.vue') },
];
```

## 重要标签理解

#### `<router-link>`

> 用来做路由导航用的，相当于 `<a>` 标签，`to` 属性指定目标地址，`tag` 属性可以把 `router-link` 标签渲染成其它标签，

`<router-link>` 比起写死的 `<a href="...">` 要好，理由如下

- 无论 history 模式 还是 hash 模式，两者表现一致
- 在 HTML5 history 模式下，`router-link` 会守卫点击事件，让浏览器**不再重新加载页面**
- 当在 history 模式下使用 `base` 选项之后， 所有的 `to` 属性都不需要再写**基准路径** 了，方便书写路径

`v-slot` [参考官方文档] https://router.vuejs.org/zh/api/#v-slot-api-3-1-0-新增

**属性**

to, 类型：`string | object`

> 被点击时，会把 to 的值传到`router.push()`中，所以这个值可以是`string | object`，也就是说在使用`js导航，push`内也是一样得

```html{6,4}
<!-- 使用 v-bind 的 JS 表达式, 就像绑定别的属性一样 -->
<router-link :to="'home'">Home</router-link>
<!-- 命名的路由，传参 -->
<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>
<!-- 带查询参数，下面的结果为 /register?plan=private -->
<router-link :to="{ path: 'register', query: { plan: 'private' }}">Register</router-link>
```

replace

> 被点击时，会调用`router.place()`，而不是`router.push()`中，这里就**不会产生** history 记录

```html
<router-link :to="{ path: '/abc'}" replace></router-link>
```

#### `<router-view>`

> 渲染路径匹配到视图组件，同时`<router-view>` 渲染的组件还可以内嵌自己的 `<router-view>`，根据**路由嵌套关系**，渲染嵌套组件。
>
> 因为它也是个组件，所以可以配合 `<transition>` 和 `<keep-alive>` 使用。如果两个结合一起用，要确保在内层使用 `<keep-alive>`

```vue
<template>
  <transition>
    <keep-alive>
      <router-view></router-view>
    </keep-alive>
  </transition>
</template>
```

**属性**

name, 类型：`string`， 默认值： `default`

> 如果 `<router-view>`设置了名称，则会渲染对应的路由配置中 `components` 下的相应组件

## Router 匹配规则构建选项

> 这里是配置路径时的选项，在`router.js`页面中使用

```javascript
interface RouteConfig = {
  path: string,
  component?: Component,
  name?: string, // 命名路由
  components?: { [name: string]: Component }, // 命名视图组件
  redirect?: string | Location | Function, // 重定向
  props?: boolean | Object | Function,
  alias?: string | Array<string>,
  children?: Array<RouteConfig>, // 嵌套路由
  beforeEnter?: (to: Route, from: Route, next: Function) => void,
  meta?: any, // 路由元信息，可以传递数据
  // 2.6.0+
  caseSensitive?: boolean, // 匹配规则是否大小写敏感？(默认值：false)
  pathToRegexpOptions?: Object // 编译正则的选项
}
```

#### router.beforeEach

> 跳转前的操作（可用来做权限验证）

```javascript
// 权限验证
router.beforeEach((to, from, next) => {
  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' });
  else next();
});
```
