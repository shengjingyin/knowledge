# 高阶配置

## 提升开发体验

### SourceMap

#### 为什么

当开发环境报错时，默认提示代码位置是编译后的位置，这样子不直观体现，需要体现开发源码

#### 是什么

是一个用来生成源代码和构建后代码的一一映射关系

它会生成一个 xxx.map 文件，里面会包含源码与构建后代码的映射关系，当构建后的代码出错时，会通过 map 文件找到源码位置，从而让浏览器提示源码出错位置

#### 怎么用

不同的环境可以配置不同的 devtool，[设置列表在这](https://webpack.docschina.org/configuration/devtool/#root)

```js
// webpack.dev.js | webpack.prod.js
module.exports = {
  devtool: 'source-map',
};
```

## 提升打包构建速度

### HotModuleReplacement

webpack 默认会将除了 css 外的所有模块全部重新打包编译，速度很慢。

### oneOf

```js
module.exports = {
  // 加载器
  module: {
    rules: [
      {
        // 只运行列表中其中一个子项
        oneOf: [
          {
            test: /\.css$/,
            use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'],
          },
          {
            test: /\.less$/,
            use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader'],
          },
        ],
      },
    ],
  },
};
```

### include / exclude

由于项目中 js 占比最多，可以对于 esliint、babel 工具进行筛选范围

```js
module.exports = {
  // 加载器
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/, // 排除
        loader: 'babel-loader',
      },
    ],
  },
  plugins: [
    // eslint 配置 https://webpack.docschina.org/plugins/eslint-webpack-plugin/
    new ESLintPlugin({
      context: path.resolve(__dirname, 'src'),
      exclude: path.resolve(__dirname, 'node_modules'), // 排除
    }),
  ],
};
```

### Cache

每次打包时 JS 都需要经过 ESlint 检查 和 Babel 编译，速度比较慢，通过对这两项内容进行缓存，便可以使二次编译时速度更快

```js
module.exports = {
  module: {
    rules: [
      {
        oneOf: [
          {
            test: /\.js$/,
            // exclude: /node_modules/, // 排除node_modules代码不编译
            include: path.resolve(__dirname, '../src'), // 也可以用包含
            loader: 'babel-loader',
            options: {
              cacheDirectory: true, // 开启babel编译缓存
              cacheCompression: false, // 缓存文件不要压缩
            },
          },
        ],
      },
    ],
  },
  plugins: [
    new ESLintWebpackPlugin({
      // 指定检查文件的根目录
      context: path.resolve(__dirname, '../src'),
      exclude: 'node_modules', // 默认值
      cache: true, // 开启缓存
      // 缓存目录
      cacheLocation: path.resolve(__dirname, '../node_modules/.cache/.eslintcache'),
    }),
  ],
};
```

### 多进程 thread

对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，所以我们要提升它们的运行速度。有多种方式开启多进程，

1、安装[thread-loader](https://webpack.docschina.org/loaders/thread-loader/)

```
npm i thread-loader -D
```

thread-loader 启动进程比较耗时，每个 worker 都是一个独立的 node.js 进程，其开销**大约为 600ms** 左右。同时会限制跨进程的数据交换。

```js
const os = require('os');
const ESLintPlugin = require('eslint-webpack-plugin');
const TerserPlugin = require('terser-webpack-plugin'); //内置压缩插件

const threads = os.cpus().length;
module.exports = {
  module: {
    rules: [
      {
        // 只运行列表中其中一个子项
        oneOf: [
          {
            test: /\.js$/,
            exclude: /node_modules/, // 排除
            use: [
              {
                loader: 'thread-loader', // 开启多进程
                options: {
                  workers: threads, // 数量
                },
              },
              {
                loader: 'babel-loader',
                options: {
                  cacheDirectory: true, // 开启babel编译缓存
                  cacheCompression: false, // 缓存文件不要压缩
                },
              },
            ],
          },
        ],
      },
    ],
  },
  plugins: [
    new ESLintPlugin({
      context: path.resolve(__dirname, 'src'),
      exclude: path.resolve(__dirname, 'node_modules'),
      threads, // 多进程
    }),
  ],
  optimization: {
    minimize: true,
    // 重写 webpack5 默认优化配置, 覆盖默认压缩工具
    minimizer: [
      new TerserPlugin({
        parallel: threads, // 多进程数量
      }),
    ],
  },
};
```

## 减少代码体积

### tree-shaking

摇树，生产环境 webpack 自动开启

### babel 优化

babel 在转译的过程中，对 syntax 的处理可能会使用到 helper 函数，对 api 的处理会引入 polyfill。

默认情况下，babel 在每个需要使用 helper 的地方都会定义一个 helper，导致最终的产物里有大量重复的 helper；引入 polyfill 时会直接修改全局变量及其原型，造成原型污染。

@babel/plugin-transform-runtime 的作用是将 helper 和 polyfill 都改为从一个统一的地方引入，并且引入的对象和全局变量是完全隔离的

1、安装[@babel/plugin-transform-runtime，点此了解](https://zhuanlan.zhihu.com/p/147083132)

```
npm i @babel/plugin-transform-runtime -D
```

2、使用

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'babel-loader',
            options: {
              plugins: ['@babel/plugin-transform-runtime'], // 减少代码体积
            },
          },
        ],
      },
    ],
  },
};
```

### 优化图片大小

[image-minimizer-webpack-plugin](https://webpack.docschina.org/plugins/image-minimizer-webpack-plugin/#root)

1、安装插件

```
npm i image-minimizer-webpack-plugin imagemin -D
```

2、无损压缩工具

```
cnpm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo --save-dev
```

3、配置

```js
const ImageMinimizerPlugin = require('image-minimizer-webpack-plugin'); // 无损压缩图片

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      // 压缩图片
      new ImageMinimizerPlugin({
        minimizer: {
          implementation: ImageMinimizerPlugin.imageminGenerate,
          options: {
            plugins: [
              ['gifsicle', { interlaced: true }],
              ['jpegtran', { progressive: true }],
              ['optipng', { optimizationLevel: 5 }],
              [
                'svgo',
                {
                  plugins: [
                    'preset-default',
                    'prefixIds',
                    {
                      name: 'sortAttrs',
                      params: {
                        xmlnsOrder: 'alphabetical',
                      },
                    },
                  ],
                },
              ],
            ],
          },
        },
      }),
    ],
  },
};
```

优化提升不明显

<!-- <img src="C:\Users\SHENGJINGYIN\AppData\Roaming\Typora\typora-user-images\image-20220618121123104.png" alt="image-20220618121123104" style="zoom:50%;" /> -->

## 优化代码运行性能

### 代码分割

#### 多入口

打包进来的文件叫 chunk，输出出去的叫 bundle

```js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  // 多入口，值为对象
  entry: {
    app: './src/app.js',
    main: './src/main.js',
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'js/[name].min.js',
    clean: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, 'public/index.html'),
    }),
  ],
  mode: 'development',
};
```

#### 多入口提取公共模块

运用`optimization.splitChunks` 分割 chunk

webpack5 默认行为

```js
module.exports = {
  optimization: {
    splitChunks: {
      // 以下代表 SplitChunksPlugin 的默认行为
      // chunks: "async", 			这表明将选择哪些 chunk 进行优化。有效值为 all，async 和 initial。设置为 all 可能特别强大，因为这意味着 chunk 可以在异步和非异步 chunk 之间共享。
      // minSize: 20000,          	生成 chunk 的最小体积（以 bytes 为单位）。
      // minRemainingSize: 0,     	确保拆分后剩余的最小 chunk 体积超过该限制
      // minChunks: 1,            	拆分前必须共享模块的最小 chunks 数。
      // maxAsyncRequests: 30,    	按需加载时的最大并行请求数。
      // maxInitialRequests: 30,  	入口点的最大并行请求数。
      // enforceSizeThreshold: 50000, 强制执行拆分的体积阈值和其他限制（minRemainingSize，maxAsyncRequests，maxInitialRequests）将被忽略。
      // cacheGroups: {				符合条件的将分组
      //     defaultVendors: {
      //         test: /[\\/]node_modules[\\/]/,
      //         priority: -10,
      //         reuseExistingChunk: true,	重复利用
      //     },
      //     default: {
      //         minChunks: 2,
      //         priority: -20,
      //         reuseExistingChunk: true,
      //     },
      // },
    },
  },
};
```

#### 模块按需加载

impot 可以实现动态导入资源

```js
document.getElementById('btn').onclick = function () {
  // 动态导入 --> 实现按需加载
  // 即使只被引用了一次，也会代码分割
  import('./math.js').then(({ sum }) => {
    alert(sum(1, 2, 3, 4, 5));
  });
};
```

#### 给模块命名

如何给按需加载的文件命名？这里需要用到“魔术贴”，两个步骤实现：

1、给导入的文件命名，使用注释的形式命名：`/*webpackChunkName: 'math'*/`

```js
import(/*webpackChunkName: 'math'*/ './js/sum').then(sum => {
  console.log(sum.default(2, 1, 2, 2, 3, 1, 5));
});
```

2、激活命名配置

```js
module.exports = {
  output: {
    chunkFilename: 'js/chunk/[name].js', // 给打包输出的其它文件命名（非入口文件）
  },
};
```

#### 输出命名

入口输出文件命名、chunk 命名、图片命名、字体图标命名、样式命名

```js
module.exports = {
  entry: './src/main.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'js/[name].js', // 入口文件输出命名
    chunkFilename: 'js/chunk/[name].chunk.js', // 给打包输出的其它文件命名（非入口文件）
    assetModuleFilename: 'media/[hash:8][ext][query]', // type:asset资源目录
  },
  plugins: [
    // 提取css为单独文件
    new MiniCssExtractPlugin({
      filename: 'css/[name].css', // 入口文件导入的css命名
      chunkFilename: 'css/[name].chunk.css', // 非入口文件导入的css命名
    }),
  ],
};
```

### preload/prefetch

在浏览器初次加载完必须要加载的资源后，利用空闲时间加载剩余需要但不紧急的资源

- preload，告诉浏览器立即加载
- prefetch，告诉浏览器在空闲时才开始加载

它们共同特点是：

- 都只会加载资源，不执行
- 都有缓存

它们的区别是：

- `preload`加载优先级高，`prefetch`加载优先级低
- `preload`只能加载当前页面需要使用的资源，`prefetch`可以加载当前页面资源，也可以加载下一个页面需要使用的资源

在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 "resource hint(资源提示)"，来告知浏览器：

- **prefetch**(预获取)：将来某些导航下可能需要的资源 prefetch (prefetch): resources that may be needed under certain navigation in the future
- **preload**(预加载)：当前导航下可能需要资源 preload (preload): resources may be required under the current navigation

1、在代码中使用，`/*webpackPrefetch: true*/` 或者 `/*webpackPreload: true*/`

```js
document.getElementById('btn').onclick = function () {
  import(/*webpackChunkName: 'math', webpackPrefetch: true*/ './js/sum').then(sum => {
    console.log(sum.default(2, 1, 2, 2, 3, 1, 5));
  });
};
```

### Network Cache

当改变子模块文件内容时，子模块变更正常，但是因为入口含有子模块的引入路径（此时，子模块的 hash 值变化了），所以入口也变化了，所以引入 runtime 文件解决引用问题变更

保存所有子文件的地址，runtime

1、使用配置

```js
module.exports = {
  optimization: {
    runtimeChunk: {
      name: entrypoint => `runtime~${entrypoint.name}.js`,
    },
  },
};
```

### 解决兼容性 js 问题

1、安装 core-js

```
cnpm i core-js
```

2、使用 core.js

有三种方式：全局导入、手动局部导入、配合 babel 智能导入

- 全局导入

  ```js
  // main.js
  import 'core-js';
  ```

- 局部导入

  ```js
  // main.js
  import 'core-js/es/promise';
  ```

- 配合 babel 智能导入

  ```js
  module.exports = {
    presets: [
      [
        '@babel/preset-env',
        // 第二个参数代表传递给@babel/preset-env 智能预设的参数
        { useBuiltIns: 'usage', corejs: { version: '3', proposals: true } },
      ],
    ],
  };
  ```

### PWA

[渐进式网络应用程序(progressive web application - PWA)](https://webpack.docschina.org/guides/progressive-web-application/#adding-workbox)，是一种可以提供类似于 native app(原生应用程序) 体验的 web app(网络应用程序)。PWA 可以用来做很多事。其中最重要的是，在**离线(offline)**时应用程序能够继续运行功能。这是通过使用名为 [Service Workers](https://developers.google.com/web/fundamentals/primers/service-workers/) 的 web 技术来实现的。

1、安装插件

```bash
npm install workbox-webpack-plugin --save-dev
```

2、配置

```js
// webpack.config.js
const WorkboxPlugin = require('workbox-webpack-plugin'); // pwa , 渐进式网络应用程序

module.exports = {
  plugins: [
    // WPA
    new WorkboxPlugin.GenerateSW({
      // 这些选项帮助快速启用 ServiceWorkers
      // 不允许遗留任何“旧的” ServiceWorkers
      clientsClaim: true,
      skipWaiting: true,
    }),
  ],
};
```

3、注册

```js
// main.js
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
      .register('/service-worker.js')
      .then(registration => {
        console.log('SW registered: ', registration);
      })
      .catch(registrationError => {
        console.log('SW registration failed: ', registrationError);
      });
  });
}
```

经过上面的配置之后，即使没有网络也能使用部分功能
