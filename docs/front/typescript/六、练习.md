```tsx
// 一般做判断需要使用到条件语句，类似三元表达式：<子类型> extends <父类型> ? <符合条件> : <不符合条件>
// 运用特性：any 与 任何类型做交叉运算都是 any 类型
type IsAny<T> = 0 extends (1 & T) ? true : false;

type a = IsAny<1> // false
type b = IsAny<any> // true


type dd = 1 extends number ? true : false // type dd = true

type c = 1 & any
type d = any extends number ? 1 : 2 // type d = 1 | 2 结果是联合类型

// 利用联合类型分布散发原理
type IsUnion<A, B = A> = A extends A 
    ? [B] extends [A]
        ? false
        : true
    : false

type f = IsUnion<123>   // type f = false
type e = IsUnion<123 | 456> // type e = true
type g = IsUnion<any> // type g = false

//

type IsNever<T> = [T] extends [never] ? true : false

type h = IsNever<never>
type i = IsNever<true>// 一般做判断需要使用到条件语句，类似三元表达式：<子类型> extends <父类型> ? <符合条件> : <不符合条件>
// 运用特性：any 与 任何类型做交叉运算都是 any 类型
type IsAny<T> = 0 extends (1 & T) ? true : false;

type a = IsAny<1> // false
type b = IsAny<any> // true


type dd = 1 extends number ? true : false // type dd = true

type c = 1 & any
type d = any extends number ? 1 : 2 // type d = 1 | 2 结果是联合类型

// 利用联合类型分布散发原理
type IsUnion<A, B = A> = A extends A 
    ? [B] extends [A]
        ? false
        : true
    : false

type f = IsUnion<123>   // type f = false
type e = IsUnion<123 | 456> // type e = true
type g = IsUnion<any> // type g = false

//

type IsNever<T> = [T] extends [never] ? true : false

type h = IsNever<never>
type i = IsNever<true>
```

