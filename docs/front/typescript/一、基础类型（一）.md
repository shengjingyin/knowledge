静态语言的一大特点：编写代码时，能根据定义时变量的类型与值类型去检查值的合法性，如果值的类型不在变量可以使用的类型范围内，ts 就会报错

举例：

```tsx
let a: number;

a = ''; // Type 'string' is not assignable to type 'number'.
```

在 ts 中的数据类型大致和 js 相同，我大致按我的理解分为：

- 基础一点的类型：boolean、number、string

- 空类型：null、undefined

- 特殊一点的类型：void、never、any

- 复杂一点的类型：array、tuple、enum

- 非原始类型：object

下面对各种类型做 demo

### boolean、number、string

```tsx
let isRun: boolean = true;
let count: number = 1;
let str: string = '';
```

像上面这种声明变量，其实它们也并非只能是它们各自声明的类型，可以想象成是一个**联合类型**，其值还可以是 null、undefined，如下所示

```tsx
let isRun: boolean = true; // isRun type: number | null | undefined

isRun = null; // 不报错
isRun = undefined; // 不报错
```

在 ts 文档中有介绍说：

> 默认情况下`null`和`undefined`是所有类型的子类型。 就是说你可以把 `null`和`undefined`赋值给`number`类型的变量。

如果你想改变上述的规则，文档也介绍了一个配置项：`strictNullChecks`，开启后，null 和 undefined 只能赋值给 void 或者它们自己。

### null、undefined

```tsx
let voidVal: null = null;
let voidVal2: undefined = undefined;

voidVal = voidVal2; // Type 'undefined' is not assignable to type 'null'.(2322)
voidVal2 = voidVal; // Type 'null' is not assignable to type 'undefined'.(2322)
```

像 null、undefined 这些都是 ts 中最底层的公民，它们一旦被确定类型，只能赋值给自己或者 void，**不能赋值给其它类型**

### 函数类型

当函数作为表达式时，可以通过类似箭头函数形式的语法为函数添加类型

### array、tuple、enum

#### array

声明 ts 中的数组有两种方式

- `类型 + []` 的形式

  ```tsx
  let arr: number[] = [1, 2];
  ```

- 数组泛型

  ```tsx
  let arr2: Array<number> = [1, 2];
  ```

#### tuple

处理数组的另一种方式，有时候我们数组中的内容并不一定都是一种类型，其中可能包含 number、string、又或者是其它类型，这时候就可以使用**元组类型（Tuple）**

```tsx
let tuple: [number, string] = [1, '2'];
```

下标选中元素时`tuple[1]`，ts 会自动推断出元素类型, 并且进行语法提示

![image-20220403182506067](https://gitee.com/sjy666666/image-host/raw/master/img/image-20220403182506067.png)

#### enum

是对 JS 数据类型的一个补充

```tsx
enum Color {
  Red,
  Green,
  Blue,
}

let c: Color = Color.Green;
```

如上所示，申明一个枚举，并且申明一个变量的值为枚举属性值，编译成 JS 代码看看 TS 做了什么

```js
(function (Color) {
  Color[(Color['Red'] = 0)] = 'Red';
  Color[(Color['Green'] = 1)] = 'Green';
  Color[(Color['Blue'] = 2)] = 'Blue';
})(Color || (Color = {}));
let c = Color.Green;
```

从上面编译后的代码中可以发现

创建对象

```
Color = {}
```

对对象声明属性

```
Color["Red"] = 0
Color[0] = "Red"
```

得出，一个枚举值会生成两个属性

综合所述，得出的就是下面这个对象，默认枚举生成的索引从 0 开始

```js
{
	0: "Red",
	"Red": 0,
	1: "Green",
	"Green": 1,
	2: "Blue",
	"Blue": 2,
}
```

如果对枚举进行索引赋值，那么索引的顺序将会改变

```tsx
enum Color {
  Red = 1,
  Green,
  Blue,
} // 1, 2, 3

(function (Color) {
  Color[(Color['Red'] = 1)] = 'Red';
  Color[(Color['Green'] = 2)] = 'Green';
  Color[(Color['Blue'] = 3)] = 'Blue';
})(Color || (Color = {}));

enum Color {
  Red,
  Green = 4,
  Blue,
} // 0, 4, 5

(function (Color) {
  Color[(Color['Red'] = 0)] = 'Red';
  Color[(Color['Green'] = 4)] = 'Green';
  Color[(Color['Blue'] = 5)] = 'Blue';
})(Color || (Color = {}));
```

当枚举值是字符串时，又会有一点区别，从输出内容可以看出，并没有进行双向创建，而是单向，只能由枚举名称查找枚举值

```tsx
enum Color {
  Red = 'rgb(2,2,2)',
  Green = 'rgb(1,1,1)',
  Blue = 3,
}

(function (Color) {
  Color['Red'] = 'rgb(2,2,2)';
  Color['Green'] = 'rgb(1,1,1)';
  Color[(Color['Blue'] = 3)] = 'Blue';
})(Color || (Color = {}));
```

### any、Object、void、never

#### any

如果想让类型检查器直接通过，那么`any`的使用是有效的，但这也损失了 TS 的类型检查，坊间有个梗，叫做 AnyScript 便是来自这个特性，对于 any 类型可以进行任意赋值，方法调用.

```tsx
let anyVal: any = 1;

anyVal.pop(); // TS并不会报错
```

#### Object

如果想要变量赋值时，不受类型限制，也可以使用`Object`类型（注意是大写的 O），但这样时，该变量并不会识别到值的方法

```tsx
let prettySure: Object = 4;

prettySure = '222'; // 不会报错

prettySure.toFixed(2); // Property 'toFixed' does not exist on type 'Object'.
```

可以看出该变量的语法提示仅支持 Object 所持有的方法 ---------- ![image-20220403205221894](https://gitee.com/sjy666666/image-host/raw/master/img/image-20220403205221894.png)

#### void

表示没有任何返回类型，通常用在函数的返回值上，而且 void 类型只能赋值`null`或者`undefined`

```tsx
function fn(): void {}

function fn(): void {
  return undefined;
}
```

#### never

never 是任何类型的子类型，所有类型的值都不能赋值给 never 类型，否则 TS 报错，即使是 any 也不行

```tsx
let anyVal: any = 1;
let val2: never = anyVal; // Type 'any' is not assignable to type 'never'.(2322)
```

那 never 有什么用处呢？搜索到一个比较好的答案是：可以穷尽

举个例子：

```tsx
type All = 'foo' | 'bar';

function handleVal(val: All) {
  switch (val) {
    case 'foo':
      // foo 逻辑
      break;
    case 'bar':
      // bar 逻辑
      break;
    default: // 不会报错
      // 这里正常时应该是不匹配任何规则，不处理任何业务，走到这里说明All类型被人为修改过
      const handleError: never = val;
      break;
  }
}
```

当视图将 All 类型进行扩展时，`handleError`就会捕获到 All 被修改，并 TS 报错提示

```tsx
type All = 'foo' | 'bar' | 'dd';
```

![image-20220403211743479](https://gitee.com/sjy666666/image-host/raw/master/img/image-20220403211743479.png)

## 类型断言

有时候机器不一定能识别出某些我们认定值的类型，这时候可以使用断言告诉机器这个变量的类型，有两种形式的断言

- ”尖括号“语法

  ```tsx
  let strVal: any = '字符串';

  let strLength: number = (<string>strVal).length;
  ```

- `as`语法

  ```tsx
  let strVal: any = '字符串';

  let strLength: number = (strVal as string).length;
  ```
