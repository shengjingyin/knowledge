TS 特点之一：对**值**所具有的**_结构_**进行**类型检查**，它有时被称做“鸭式辨型法”或“结构性子类型化”。

接口的作用就是为这些**类型命名**和**为你的代码签订契约**，以接口的结构去检查你的代码

## 对象类型

举例：定义变量缺少接口定义的参数时，TS 报错提示缺少参数

```tsx
interface Person {
    name: string;
    age: number;
}

// Property 'age' is missing in type '{ name: string; }' but required in type 'Person'.(2741)
let p1: Person = {
    name: "",
};
```

当然，接口中的参数还有几种模式

### 可选

假设想让上述实例不报错，那么我们可以设置`age`属性为可选属性，需要使用符号 **?**，重新定义接口如下，即可避免 TS 报错

```tsx
interface Person {
    name: string;
    age?: number; // ? 符号 代表可选参数
}
```

### 只读

为了避免其他人操作`name`属性，可以设置其为只读属性，需要使用关键词 **readonly**

```ts
interface Person {
    readonly name: string; // 只读属性，不能被修改
    age?: number;
}
```

### 字符串索引签名（任意属性）

因为有前面书写的接口定义`p1变量`，所以我无法再给它添加任何其它变量，比如尝试新增一个`hobby`属性，此时 TS 报错说`hobby`不存在于接口`Person`当中

```tsx
let p1: Person = {
    name: "",
    hobby: "篮球", // Type '{ name: string; hobby: string; }' is not assignable to type 'Person'.
    // Object literal may only specify known properties, and 'hobby' does not exist in type 'Person'.(2322)
};
```

这时，任意属性来了，重新定义接口如下：

```tsx
interface Person {
    readonly name: string;
    age?: number;
    [xx: string]: any; // 代表任意属性，此时添加任何string类型的属性都是可以的
}
```

经过上面的改造，可以安全添加`hobby`属性

```tsx
let p1: Person = {
    name: "",
    hobby: "篮球",
    ddd: {},
    2: "", // key 2 （number）应该是会被转成字符串 “2”
};
```

通过 任意属性 添加的 key，并不会存在于语法提示中

<img src="D:\Project\image-host\img/image-20220409111217869.png" alt="image-20220409111217869" style="zoom:50%;" />

#### 注意点

一旦使用了任意属性，那么其它譬如：**可选/只读/确定属性的值类型，都必须是任意属性值类型的 子类型**，比如我更改接口结构如下：

```tsx
interface Person {
    readonly name: string;
    age?: number; // Property 'age' of type 'number | undefined' is not assignable to 'string' index type 'string'.(2411)
    [xx: string]: string;
}
```

解析：因为字符串索引类型（任意项）的值类型为`string`，所以不能把 age 的类型设置为`number | undefined`并分配给`string`，也就是说：**可选/只读/确定属性的值类型，都必须是任意属性值类型的 子类型**

通过扩大任意类型的值类型范围，可解决，改造如下：

```tsx
// 方法一
interface Person {
    readonly name: string;
    age?: number;
    [xx: string]: string | number | undefined; // 扩大值类型范围
}

// 方法二
interface Person {
    readonly name: string;
    age?: number;
    [xx: string]: any; // 任意类型 是 any 子类型
}
```

### 字符串、数字索引类型

在 TS 中 支持两种索类型：数字和字符串，两种索引类型可以同时使用，但是 **数字索引的返回值必须是字符串索引返回值类型的子类型**

解析：因为使用 `number`来索引时，JS 会将它转换成`string`然后再去索引对象，这就是原因所在

```tsx
class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
}

class Dog extends Animal {
    breed: string;
    constructor(name: string) {
        super(name);
        this.breed = "汪汪汪~";
    }
}
// 错误示例
interface NotOk {
    [n: number]: Animal; // 报错，'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.
    [s: string]: Dog;
}
```

> 因为数字索引的值必须为字符串索引值得子类型，而 Animal 是 Dog 父类，解决报错的方法就是 调换 值的位置

```tsx
// 正确示例
interface IsOk {
    [n: number]: Dog;
    [s: string]: Animal;
}
```

## 函数类型

上面介绍了关于接口如何去约束对象，那么作为 JS 中的一等公民函数，我该如何去约束呢，同样可以 使用接口去约束，举例：

```tsx
function isNum(n: any): boolean {
    return typeof n === "number";
}
```

使用 接口 约束

```tsx
interface IsNum {
    (n: any): boolean
}

// 正确示范
const isNum: IsNum = function (n) {
    return typeof n === 'number'
}
// 错误示范
function isNum: IsNum (n) {
    return typeof n === 'number'
}
```

> 接口内的参数名与函数的参数名可以不同，TS 会对函数的参数逐个进行检查，要求对应位置上的参数类型是兼容的

## 类类型

接口约束类示例：

```tsx
interface Time {
    time: Date;
    setTime(): void;
}

class Clock implements Time {
    time: Date;
    constructor() {
        this.time = new Date();
    }
    setTime() {
        this.time = new Date(new Date().getTime() + 2000);
    }
    getPreTime() {
        this.time = new Date(new Date().getTime() - 2000);
    }
}
```

类实现接口时，只会对实例部分进行类型检查。`constructor构造器`属于静态部分，所以 TS 不会去检查，

-   约束构造器，报错

    > Class 'Clock' incorrectly implements interface 'Time'. Type 'Clock' provides no match for the signature 'new (): any'.

    ```tsx
    interface Time {
        time: Date;
        setTime(diff: number): void;
        new (): any; // 报错
    }
    ```

-   约束静态方法

    TS 无法检查静态部分

    > Class 'Clock' incorrectly implements interface 'Time'. Property 'getPreTime' is missing in type 'Clock' but required in type 'Time'.

    ```tsx
    interface Time {
        time: Date;
        setTime(diff: number): void;
        getPreTime(): void; // 报错
    }

    class Clock implements Time {
        time: Date;
        constructor() {
            this.time = new Date();
        }
        setTime() {
            this.time = new Date(new Date().getTime() + 2000);
        }
        static getPreTime() {
            console.log("调用静态方法");
        }
    }
    ```

## 应用
