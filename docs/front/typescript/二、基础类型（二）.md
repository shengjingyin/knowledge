## 基础

### 枚举

```typescript
enum Status {
    success,
    error,
    normal,
}
function getS(status: number): string {
    if (status === Status.success) {
        return "success";
    }
    return "error";
}
for (let v in Status) {
    console.log(v);
}
console.log(Status[0], Status[1], Status[2], Status.error);
console.log(getS(0));
```

```
[LOG]: "0"
[LOG]: "1"
[LOG]: "2"
[LOG]: "success"
[LOG]: "error"
[LOG]: "normal"
[LOG]: "success",  "error",  "normal",  1
[LOG]: "success"
```

#### 遍历

可以使用`for in`遍历枚举

### 泛型

#### 泛型继承接口实现泛型属性约束

```typescript
interface Lengthwise {
    length: number;
}

function identity<T extends Lengthwise>(args: T): T {
    console.log(args.length);
    return args;
}

console.log(identity("123"));
```

## 进阶

### 联合类型

![](D:\Project\image-host\img/image-20211209121326193.png)

ts 语法只会提示联合类型的公共部分，私有属性不会提醒

```typescript
function add(a: number | string, b: number | string) {
    return a + b; // error: Operator '+' cannot be applied to types 'string | number' and 'string | number'.
}
let r = add(1, 2);
console.log(r);
```

参数为联合类型时，直接运算会报 ts 错误，解决的办法需要进行类型保护，常见的类型保护有四种，见下一节内容

### 类型保护

#### 断言

有时候你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。

类型断言有两种形式。 其一是“尖括号”语法：

```ts
let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;
```

另一个为`as`语法：

```ts
let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
```

然而，当你在 TypeScript 里使用 JSX 时，只有 `as`语法断言是被允许的。

了解断言后，我们来试着解决上一节的错误内容

```tsx

```

#### in

#### typeOf

#### instanceOf

## 高阶

## 类型断言

## 接口使用

接口可以在多种场景使用：类、对象属性、函数

-   类使用接口

    ```typescript
    interface point {
        x: number;
        y: number;
    }

    class somePoint implements point {
        x;
        y;
        constructor() {
            this.x = 1;
            this.y = 1;
        }
    }
    ```

-   对象属性使用接口

    ```typescript
    interface userInfo {
        name: string;
        age: number;
        readonly hobby: string; // 只读属性
        sex?: string; // 可选属性
        [s: string]: any; // 任意属性, 属性名<s>可以随意取值
    }

    const juliya: userInfo = {
        name: "猪猪",
        age: 23,
        sex: "male",
        add: 123,
        sd() {
            this.name = "juliya";
        },
    };
    ```

-   函数使用接口

    ```typescript
    interface Func {
        (a: number, b: number): number;
    }

    const add: Func = function(a, b) {
        return a + b;
    };
    ```

## 类

### 属性修饰符

-   public（默认值）

-   private（私有值）

    只能在声明的类中修改，在子类以及实例中不能修改该修饰符对应的属性值

-   protected（受保护值）

    与 private 行为类似，但是可以在子类和声明类中修改

-   readonly（只读）

-   get、set（存取器）

    只带有 `get`不带有 `set`的存取器自动被推断为 `readonly`

-   static (静态属性(通过 class 访问)) （class 原生支持）

-   abstract (抽象类)

    抽象类做为其它派生类的基类使用。 它们**一般不会直接被实例化**(不能直接 new 操作符使用,只能被继承)。
