## 和 vue 语法区别

|     | vue  | react |
| --- | ---- | ----- |
| jsx | 支持 | 支持  |
|     |      |       |
|     |      |       |

## 组件

用来实现局部功能效果的代码和资源的集合（html、css、js）

### 函数式组件

- 用于创建简单组件，返回 jsx
- 自定义组件以大写字母开头

```jsx
function Demo() {
  console.log(this); // unndefined，为什么是undefined？
  return <div>函数式组件</div>;
}
ReactDOM.render(<Demo />, document.getElementById('App'));
```

#### 为什么是 undefined？

经过 babel 翻译之后（开启了严格模式），导致组件中的 this 指向 undefined。其实 jsx 是原始 js 的语法糖

![image-20221113172853609](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9af4e8f597e34211bb2a36623d6e2863~tplv-k3u1fbpfcp-zoom-1.image)

#### ReactDOM.render 调用之后做了什么？

- React 解析组件标签，找到对应组件
- 根据组件类别调用对应逻辑，将 render 返回的虚拟 dom 转为真实 dom，呈现在页面中

### 类式组件

- 继承自 `React.Component`
- 定义实例方法：`render`
- 状态不可以直接更改，需要使用 `setState` 才能更改

```jsx
class Demo extends React.Component {
  render() {
    console.log(this); // 组件实例
    return <div>函数式组件</div>;
  }
}
ReactDOM.render(<Demo />, document.getElementById('App'));
```

#### ReactDOM.render 调用之后做了什么？

- React 解析组件标签，找到对应组件；
- 发现组件是类定义的。随后 new 出来实例，并通过该实例调用原型上的 render 方法；
- 将 render 返回的虚拟 dom 转为真实 dom，呈现在页面中。

#### 绑定状态与事件

```js
class Demo extends React.Component {
  state = {
    isHot: true,
    label: '炎热',
  };
  /* 箭头函数绑定this为当前实例，因为react调用该方法时，并不是用实例调用的，所以this不是指向实例，需要用箭头函数绑定当前函数的this指向 */
  toggleWeather = () => {
    const isHot = !this.state.isHot,
      label = isHot ? '炎热' : '凉爽';
    this.setState({
      isHot,
      label,
    });
  };
  render() {
    return (
      <h1>
        天气: {this.state.label}
        /* 将toggleWeather函数做为onClick的回调，当事件被触发时，直接调用函数，所以this指向不是实例 */
        <button onClick={this.toggleWeather}>切换</button>
      </h1>
    );
  }
}
ReactDOM.render(<Demo />, document.getElementById('App'));
```

> 通常，在 React 中，构造函数仅用于以下两种情况：
>
> - 通过给 `this.state` 赋值对象来初始化[内部 state](https://zh-hans.reactjs.org/docs/state-and-lifecycle.html)。
> - 为[事件处理函数](https://zh-hans.reactjs.org/docs/handling-events.html)绑定实例

#### 事件

将所有原生事件进行转换：例如将：onclick 转换成 onClick

#### 为什么绑定的组件需要以箭头函数的形式？

```js
class Demo extends React.Component {
  /* 箭头函数绑定this为当前实例 */
  toggleWeather = () => {};
}
```

#### render 函数和 constructor 函数分别调用了多少次

constructor 函数：1 次 （初始化时，new 一次；多个组件时，调用多次）

render 函数：1 + n 次（n 是状态更新的次数）

#### props

+ 同vue类似，单向数据流，不能修改

+ 构造器是否接受props，是否传递给super，取决于：是否希望在构造器中通过this访问props，如果没有传递props给super，那么无法通过this访问props

  ```js
  class Demo extends React.Component {
      constructor() {
          super();
          console.log("this.props", this.props); // undefined;
      }
      constructor(props) {
          super();
          console.log("this.props", this.props); // undefined;
      }
      constructor(props) {
          super(props);
          console.log("this.props", this.props); // 有值
      }
  }
  ```

  

+ 实例身上有props属性，可以通过`this.props`获取初始值

```js
const person = { name: "Tom", age: 19 };
ReactDOM.render(<Demo name={person.name} age={person.age} />, document.getElementById("App"));
```

+ props简写，`...Judge`仅适用于标签属性传递

```jsx {2}
const Judge = { name: "Judge", age: 20 };
ReactDOM.render(<Demo {...Judge} />, document.getElementById("App2"));
```

+ 对props做限制

对构造函数添加 `propTypes` 属性

> 版本 < 15.6; 也就是15版本使用这种

```js
Demo.propTypes = {
    name: React.PropTypes.string,
    age: React.PropTypes.number.isRequired,
};
```

> 版本 >= 15.6;  新版本写法

```js
Demo.propTypes = {
    name: PropTypes.string,
    age: PropTypes.number.isRequired,
};
// or
class Demo {
	static propTypes = {
        name: PropTypes.string,
        age: PropTypes.number.isRequired,
    };
}
```



```js
import React from 'react';
import PropTypes from 'prop-types';

class MyComponent extends React.Component {
  render() {
    // ... do things with the props
  }
}

MyComponent.propTypes = {
  // 所有类型
  optionalArray: PropTypes.array,
  optionalBigInt: PropTypes.bigint,
  optionalBool: PropTypes.bool, // 特殊值
  optionalFunc: PropTypes.func, // 特殊值
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,

  // Anything that can be rendered: numbers, strings, elements or an array
  // (or fragment) containing these types.
  // see https://reactjs.org/docs/rendering-elements.html for more info
  optionalNode: PropTypes.node,

  // A React element (ie. <MyComponent />).
  optionalElement: PropTypes.element,

  // A React element type (eg. MyComponent).
  // a function, string, or "element-like" object (eg. React.Fragment, Suspense, etc.)
  // see https://github.com/facebook/react/blob/HEAD/packages/shared/isValidElementType.js
  optionalElementType: PropTypes.elementType,

  // You can also declare that a prop is an instance of a class. This uses
  // JS's instanceof operator.
  optionalMessage: PropTypes.instanceOf(Message),

  // You can ensure that your prop is limited to specific values by treating
  // it as an enum.
  optionalEnum: PropTypes.oneOf(['News', 'Photos']),

  // An object that could be one of many types
  optionalUnion: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.instanceOf(Message),
  ]),

  // An array of a certain type
  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),

  // An object with property values of a certain type
  optionalObjectOf: PropTypes.objectOf(PropTypes.number),

  // isRequired 表示必传

  // An object taking on a particular shape
  optionalObjectWithShape: PropTypes.shape({
    optionalProperty: PropTypes.string,
    requiredProperty: PropTypes.number.isRequired,
  }),

  // An object with warnings on extra properties
  optionalObjectWithStrictShape: PropTypes.exact({
    optionalProperty: PropTypes.string,
    requiredProperty: PropTypes.number.isRequired,
  }),

  requiredFunc: PropTypes.func.isRequired,

  // A value of any data type
  requiredAny: PropTypes.any.isRequired,

  // You can also specify a custom validator. It should return an Error
  // object if the validation fails. Don't `console.warn` or throw, as this
  // won't work inside `oneOfType`.
  customProp: function (props, propName, componentName) {
    if (!/matchme/.test(props[propName])) {
      return new Error(
        'Invalid prop `' +
          propName +
          '` supplied to' +
          ' `' +
          componentName +
          '`. Validation failed.'
      );
    }
  },

  // You can also supply a custom validator to `arrayOf` and `objectOf`.
  // It should return an Error object if the validation fails. The validator
  // will be called for each key in the array or object. The first two
  // arguments of the validator are the array or object itself, and the
  // current item's key.
  customArrayProp: PropTypes.arrayOf(function (
    propValue,
    key,
    componentName,
    location,
    propFullName
  ) {
    if (!/matchme/.test(propValue[key])) {
      return new Error(
        'Invalid prop `' +
          propFullName +
          '` supplied to' +
          ' `' +
          componentName +
          '`. Validation failed.'
      );
    }
  }),
};
```



+ 默认值

可以只传部分属性的默认值

```js
Demo.defaultProps = {
    name: "刘德华",
};
// or
class Demo {
	static defaultProps = {
        name: "刘德华",
    };
}
```



+ 函数式组件使用props

  ```jsx
  function Demo(props) {
      const {name, age} = props
      return (
          <ul>
              <li>名字：{name}</li>
              <li>年龄：{age}</li>
          </ul>
      );
  }
  Demo.propTypes = {
      name: PropTypes.string,
      age: PropTypes.number.isRequired,
  };
  const person = { name: "Tom", age: 19 };
  ReactDOM.render(<Demo name={person.name} age={person.age} />, document.getElementById("App"));
  ```

  



#### ref

+ 1.字符串形式ref（存在一些问题，官方已经不推荐）

  ```jsx
  showData = () => {
      const { input1: $input1 } = this.refs;
  };
  render() {
  	return (<div>
          <input ref="input1" type="text" placeholder="点击提示数据" />
          <input ref="input2" type="text" onBlur={this.showData2} placeholder="失去焦点提示数据" />
      </div>)
  }
  ```

+ 回调函数形式ref

  > 接受一个参数表示当前元素

  ```jsx
  <input ref={(c) => (this.input1 = c)} type="text" placeholder="点击提示数据" />
  ```

  上面这种 `ref` 回调函数是以**内联函数**的方式定义的，在**更新过程中它会被执行两次**，第一次传入参数 `null`，然后第二次会传入参数 DOM 元素。这是因为<u>在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。</u>

  解决办法：将 ref 的回调函数定义成 **class 的绑定函数**的方式可以避免上述问题

  ```jsx
  saveInput = (c) => {
      this.input1 = c
  }
  render() {
      return <input ref={this.saveInput} type="text" placeholder="点击提示数据" />
  }
  ```

  

+ createRef形式的ref （官方推荐）

  ```jsx {3}
  class Demo extends React.Component {
      // React.createRef 调用后返回一个容器，该容器可以存储被ref所标识的节点，类似vue3中的ref()
      input1 = React.createRef();
      render() {
          return <input ref={this.input1} type="text" placeholder="点击提示数据" />
      }
  }
  ```



#### 事件处理

+ 通过 `onXx` 属性指定事件处理函数（注意大小写）
  + react事件通过事件委托方式处理的（委托给最外层元素，原理：事件冒泡），为了高效

+ 非受控组件

  现用现取，比如点击的时候再去获取数据

+ 受控组件（推荐），减少ref的使用

  实时更新

## 路由 react-router

- 基于**history**

- 基于**hash**
